Object Vs Map

Когда в качестве ключей используются последовательные целые числа, обычный Object будет быстрее, да.
В общем случае использования произвольных строк в случайном порядке Map будет работать значительно лучше, чем Object.
Для map: вы можете легко получить размер карты (myMap.size)
Для map: map также гарантируют сохранение порядка

Производительность:
Object: Не оптимизирован для частого добавления и удаления пар ключ-значение.
Map: Лучше работает в сценариях с частыми добавлениями и удалениями пар ключ-значение.

Приколы Map:
У простых объектов и массивов есть последнее преимущество перед картами и наборами - сериализация(JSON.stringify).
	JSON.stringify(obj, null, 2)
Оказывается, второй параметр может быть нам очень полезен. Он называется replacer и позволяет нам определить, как должен быть сериализован любой пользовательский тип.
Мы можем использовать его, чтобы легко преобразовывать карты и множества в объекты и массивы для сериализации
	JSON.stringify(obj, (key, value) => {
		// Преобразование map в простые объекты
		if (value instanceof Map) {
		  return Object.fromEntries(value)
		}
		// Преобразование set в массивы
		if (value instanceof Set) {
		  return Array.from(value)
		}
		return value
	})

Map можно объединять с массивами и преобразовывать в массивы
let arr = [ [1, 'one'], [2, 'two'] ];
new Map(arr); //{ 1 => 'one', 2 => 'two' }

let map = new Map([ [1, 'one'], [2, 'two'] ]);
Array.from(map) //[ [1, 'one'], [2, 'two'] ]

Converting an Object to a Map:
	const map = new Map(Object.entries(birds));
	
Converting an Object to Set
	const set = new Set(Object.values(foods));


Использование map: 
1. При выполнении хеширования.
2. Когда у вас может быть любое количество ключей, и вам может потребоваться часто добавлять и удалять ключи, подумайте об использовании map для лучшей производительности и эргономики..

Использование object:
1. Для структурированных объектов, которые имеют четко определенный набор ключей - например, если каждое событие должно иметь заголовок и дату - вам обычно нужен объект. Они очень оптимизированы для быстрого чтения и записи, когда у вас есть фиксированный набор ключей.
2. При работе с данными JSON, Objects имеют прямую поддержку в JSON, а Maps - нет.

Итог:
Объекты идеально подходят для небольших и средних наборов данных.
Map обеспечивает лучшую производительность при работе с большими объемами данных.





Set vs Array

Класс Set является дополнением класса Array

Нижеперечисленное справедливо только для методов, но не для for...of:
Большинство операций над Array javascript, таких как вставка, удаление, поиск и т.д., являются операциями линейного времени. Для их выполнения требуется время O(n), где n - размер массива. 
Но так как Set используют ключи для хранения элементов, большинство операций занимают постоянное время O(1). Таким образом, размер множеств не влияет на производительность коллекций множеств.

Операции с массивами в Javascript, такие как вставка, удаление и поиск, занимают линейное время, которое зависит от количества элементов, присутствующих в массиве.

При создании массива, где порядок элементов имеет значение, и вы можете намеренно хотеть дубликаты в массиве, тогда обычный массив - это, как правило, отличная идея.
// Для упорядоченных списков или тех, где могут понадобиться дубликаты элементов, используйте Array
const myArray = [1, 2, 3, 2, 1].
Но если вы знаете, что вам никогда не нужны дубликаты и порядок элементов не имеет значения, используйте набор.
// Для неупорядоченных уникальных списков используйте Set





WeakMap и WeakSet
???
WeakMap нужна для кэширования и предотвращает утечку памяти (Так что пока скип)
Иногда быстрее не кэшировать функцию. Если выполнение вашей функции занимает всего миллисекунду, то кэширование замедлит ее работу.

есть работа, для которой WeakMap подходят лучше. Например, добавление дополнительных метаданных к объектам.

Гуглишь по WeakMap
use cases weakmap

Одним из простых примеров может быть система входа в систему. Вы можете отслеживать пользователей (объекты), которые находятся в сети, добавляя их в WeakSet.





for, while vs Array methods vs Object Methods
for, while будут быстрее Array/Object methods
for лучше использовать для большого количества элементов (>=100)





Примечание:
Все зависит от браузера, Set может быть не намного быстрее Array в Chrome, но в Safari там полет в космос от Set по сравнению с Array (Также в некоторых моментах Array будет быстрее)

Меньшее количество строк кода означает более короткое время разработки и меньшую нагрузку на обслуживание - оптимизируйте сначала для удобства разработчиков, а затем для производительности.





Вопросы:
1. A?
медленно (например, 18 мс) new Set(bigArray)

быстро (например, 6 мс) const SET = new Set();
  const L = bigArray.length;
  for(var i = 0; i<L; i++) { SET.add(bigArray[i]) }

2.
array.at vs index vs pop
3.
object.value vs object[value]

https://dev.to/
https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html
