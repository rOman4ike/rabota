"source" code (./src)
"distribution" code (./dist)

"source code" - это код, который мы будем писать и редактировать.
"distribution code" - то минимизированный и оптимизированный результат процесса сборки, который в конечном итоге будет
  загружен в браузер.

"dependency graph" -

"entry point" -

"output point" -

"build directory" -

"parser" - можно импортировать любой файл toml, yaml или json5 в качестве JSON-модуля, используя не специальный загрузчик
  webpack, а собственный парсер.

"manifest" - Возможно, вам интересно, как webpack и его плагины "узнают", какие файлы генерируются. Ответ кроется в
  манифесте, который webpack ведет для отслеживания того, как все модули соотносятся с выходными пакетами.

"stack trace" -

"source maps" -

"safe mode" - https://webpack.js.org/guides/development/#adjusting-your-text-editor

"watch mode" -

"live reloading" -

"chunk" -

"code splitting" - одна из наиболее привлекательных возможностей webpack.
  Эта функция позволяет разделить код на различные bundles(пакеты), которые могут загружаться по требованию или параллельно.
  С ее помощью можно добиться уменьшения размера bundles(пакетов) и управлять приоритетом загрузки ресурсов, что при правильном
    использовании может существенно повлиять на время загрузки.

"bundles" - ???

"split chunks" - ???

"prefetching" - ???

"preloading" - ???

Подключение библиотек:
  Чтобы подключить зависимость lodash к index.js, нам потребуется установить библиотеку локально:
    npm install --save lodash

  При установке пакета, который будет включен в production пакет, следует использовать:
    npm install --save

  Если вы устанавливаете пакет для целей разработки (например, линтер, тестовые библиотеки и т.д.), то следует использовать
    npm install --save-dev

Команды:
  Команда npx, поставляемая с Node 8.2/npm 5.2.0 или выше, запускает бинарный файл webpack (./node_modules/.bin/webpack) пакета webpack
    npx webpack

  Запустить сборку с помощью конфигурационного файла:
    npx webpack --config webpack.config.js
  Если присутствует файл webpack.config.js, команда webpack подхватывает его по умолчанию.
  Опция --config используется здесь только для того, чтобы показать, что можно передавать конфигурацию с любым именем.
  Это будет полезно для более сложных конфигураций, которые необходимо разделить на несколько файлов.

Модули:
  За кулисами webpack фактически "транспилирует" код, чтобы старые браузеры также могли работать с ним.
  Если вы посмотрите на файл dist/main.js, то сможете увидеть, как webpack это делает, - это весьма изобретательно!
  Помимо импорта и экспорта, webpack поддерживает и другие синтаксисы модулей

Использование конфигурации:
  Начиная с версии 4, webpack не требует никакой конфигурации (webpack.config.js)

NPM Scripts:
  Пользовательские параметры можно передать webpack например:
    npm run build -- --color.

Безопасность емое:
  Не компилируйте недоверенный код с помощью webpack. Это может привести к выполнению вредоносного кода на вашем компьютере,
    удаленных серверах или в Web-браузерах конечных пользователей вашего приложения.

Просто инфа блин:
  До появления webpack разработчики фронтенда использовали такие инструменты, как grunt и gulp

Asset Management:
  Одной из самых замечательных возможностей webpack является то, что вы также можете включать в пакет любые другие типы
  файлов, помимо JavaScript, для которых существует загрузчик (loader) или встроенная поддержка Asset Modules.

  Загрузчики модулей могут быть объединены в цепочку.
  Цепочка выполняется в обратном порядке.

  Первый загрузчик передает свой результат (ресурс с примененными преобразованиями) следующему, и так далее.
    use: ['style-loader', 'css-loader']
  При импорте в .js файл и запуске build-комманды тег <style> динамически создастся JavaScript (в dist не будет, а в коде элемента будет)

  Для определения того, какие файлы следует передавать определенному загрузчику, webpack использует регулярное выражение.
    test: /\.css$/i,

  Модули Asset Modules принимают любой файл, который вы загружаете через них, и выводят его в каталог сборки(build directory).

  Поддержка JSON фактически встроена, как и в NodeJS, то есть импорт Data из './data.json' будет работать по умолчанию (loader не нужен).

  Вы также можете импортировать любой из этих четырех типов данных (JSON, CSV, TSV, XML) с помощью loader

  'ВАЖНО!'
    Без предупреждения можно использовать только стандартный экспорт JSON-модулей.
      // No warning
      import data from './data.json';
      // Warning shown, this is not allowed by the spec.
      import { foo } from './data.json';

Output Management:
  До сих пор мы вручную включали все наши активы в файл index.html, но по мере роста вашего приложения, когда вы начнете
    использовать хэши в именах файлов и выводить несколько пакетов, будет сложно продолжать управлять файлом index.html вручную.

  Однако существует несколько плагинов, которые значительно облегчают этот процесс.

  Что произойдет, если мы изменим имя одной из наших точек входа или даже добавим новую?
  Сгенерированные пакеты будут переименованы при сборке, но наш файл index.html по-прежнему будет ссылаться на старые имена.
  Давайте исправим это с помощью плагина HtmlWebpackPlugin.

  'HtmlWebpackPlugin' по умолчанию генерирует собственный файл index.html, даже если он уже есть в папке dist/.

  Webpack генерирует файлы и помещает их в папку /dist, но он не следит за тем, какие файлы действительно используются в проекте.
  Давайте позаботимся об этом с помощью опции output.clean.

  Данные манифеста могут быть извлечены в json-файл для использования с помощью плагина 'WebpackManifestPlugin'.

Development:
  'ВАЖНО!'
    Инструменты, приведенные в этом руководстве, предназначены только для разработки, пожалуйста, не используйте их на production!
      mode: 'development'

  Когда webpack объединяет исходный код, отследить ошибки и предупреждения до их первоначального местоположения может быть затруднительно.
  Например, если собрать три исходных файла (a.js, b.js и c.js) в одну связку (bundle.js) и один из них содержит ошибку,
    то трассировка стека будет указывать на bundle.js.

  Для облегчения поиска ошибок и предупреждений JavaScript предлагает source maps, которые отображают скомпилированный
    код обратно на исходный код. Если ошибка возникла в файле b.js, то карта исходного кода точно укажет на это.

  В данном руководстве мы будем использовать вариант inline-source-map, который хорошо подходит для иллюстративных целей (но не для производства):
    devtool: 'inline-source-map'

  Некоторые текстовые редакторы имеют функцию "safe mode" которая может мешать работе с некоторыми из перечисленных
    ниже инструментов.

  Запускать вручную npm run build каждый раз, когда требуется скомпилировать код, быстро становится хлопотно.
  В webpack есть несколько различных опций, позволяющих автоматически компилировать код при каждом его изменении:
    1. webpack Watch Mode
      Вы можете поручить webpack «смотреть» все файлы в вашем графе зависимостей на предмет изменений.
      Давайте добавим скрипт npm, который будет запускать режим просмотра веб-пакета:
        "watch": "webpack --watch",
      Единственным недостатком является то, что вам придется обновить браузер, чтобы увидеть изменения.
    2. webpack-dev-server
      Webpack-dev-server предоставляет вам элементарный веб-сервер и возможность использовать "live reloading".
        npm install --save-dev webpack-dev-server
      Измените файл конфигурации, чтобы сообщить серверу разработки, где искать файлы:
        devServer: {
          static: './dist',
        },
        optimization: {
          runtimeChunk: 'single',
        },
      'ВАЖНО!'
        optimization.runtimeChunk: 'single' был добавлен, поскольку в этом примере на одной HTML-странице имеется более одной точки входа.
        Прочтите главу 'Code Splitting' для получения более подробной информации.
      'ВАЖНО!'
        webpack-dev-server обслуживает связанные файлы из каталога, определенного в output, т. е. файлы будут доступны по адресу
          http://[devServer.host]:[devServer.port]/[output.publicPath]/[output.filename] ].
      'ВАЖНО!'
        webpack-dev-server не записывает output files после компиляции.
        Вместо этого он сохраняет файлы пакета в памяти и обслуживает их, как если бы они были реальными файлами,
          смонтированными по server's root path.
      Webpack-dev-server имеет множество настраиваемых параметров. Перейдите к документации, чтобы узнать больше.
    3. webpack-dev-middleware
      webpack-dev-middleware — это оболочка, которая отправляет файлы, обработанные webpack, на сервер.
      Он используется внутри webpack-dev-server, однако он доступен как отдельный пакет, чтобы при желании можно было
        выполнить дополнительные настройки.
      Нам нужно внести некоторые изменения в файл конфигурации нашего веб-пакета
        publicPath: '/',
  В большинстве случаев, вероятно, лучше использовать webpack-dev-server

Code Splitting:
  Существует три общих подхода к code splitting:
    1. Entry Points: Ручное разделение кода с помощью конфигурации entry.
      Самый простой и интуитивно понятный способ разделения кода.
      Однако он более ручной и имеет некоторые подводные камни:
        1. Если между entry чанками есть дублирующиеся модули, то они будут включены в оба пакета.
        2. Он не так гибок и не может быть использован для динамического split code с основной логикой приложения.

    2. Prevent Duplication: Использование зависимостей Entry или плагина 'SplitChunksPlugin' для dedupe(дедупликации)
      и split chunks(разделения фрагментов).
    3. Dynamic Imports: split code с помощью вызовов встроенных функций внутри модулей.

  Если мы собираемся использовать несколько entry point на одной HTML-странице, то optimization.runtimeChunk: 'single'
    тоже необходим, иначе мы можем столкнуться с проблемами, описанными здесь(https://bundlers.tooling.report/code-splitting/multi-entry/).

  Хотя в webpack допускается использование нескольких entry point для каждой страницы, по возможности следует избегать этого,
    предпочитая использовать точку входа с несколькими импортами: entry: { page: ['./analytics', './app'] }.
  Это приводит к лучшей оптимизации и согласованному порядку выполнения при использовании тегов async-сценариев.

  Плагин 'SplitChunksPlugin' позволяет извлекать общие зависимости в существующий entry chunk или в совершенно новый chunk.
    optimization: {
      splitChunks: {
        chunks: 'all',
      },
    },

  При динамическом code splitting webpack поддерживает две схожие техники. Первый и рекомендуемый подход заключается
    в использовании синтаксиса import(), который соответствует предложению ECMAScript для динамического импорта.
  Специфичный для webpack подход заключается в использовании require.ensure.
  "ВАЖНО!"
    Вызовы import() используют внутренние Promise. Если вы используете import() в старых браузерах (например, IE 11),
      не забудьте экранировать Promise с помощью полифилла, например es6-promise или promise-polyfill.

  Webpack 4.6.0+ adds support for prefetching and preloading.
  Использование этих инлайн-директив при объявлении импорта позволяет webpack выводить "Resource Hint", который сообщает
    браузеру, что для:
    1. prefetch: ресурс, вероятно, понадобится для некоторой навигации в будущем
    2. preload: ресурс также будет необходим во время текущей навигации
  В качестве примера можно привести компонент HomePage, который отображает компонент LoginButton, а затем по запросу
    загружает компонент LoginModal после нажатия на него.
  "ВАЖНО!"
    webpack добавит подсказку prefetch после загрузки родительского chunk

  Директива Preload имеет ряд отличий от prefetch:
    1. a preloaded chunk начинает загружаться параллельно с parent chunk.
      a prefetched chunk запускается после завершения загрузки родительского чанка.
    2. a preloaded chunk имеет средний приоритет и загружается мгновенно.
      a prefetched chunk загружается во время простоя браузера.
    3. a preloaded chunk должен быть мгновенно запрошен родительским чанком.
      a prefetched chunk может быть использован в любое время в будущем.
    4. Поддержка браузеров различна
    5.

ВОПРОСЫ:
  1. Динамический импорт библиотек