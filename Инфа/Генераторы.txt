

Итерируемые объекты и итераторы:
	Начнем с итерируемых объектов. Что это такое? Это нечто, что может быть итерировано, например:
		for (let element of iterable) {}
		
	Но мы пока не знаем, как они обрели возможность быть итерируемыми. Ответ прост: существуют ассоциированные с ними итераторы.

	Итератор — объект, содержащий метод next. При вызове этого метода он должен возвращать:
		следующее значение в последовательности значений;
		информацию о том, закончил ли итератор генерировать значения.
		
	Теперь можно понять, что делает for ... of под капотом:
		первый метод [Symbol.iterator]() вызывается для получения итератора;
		метод next циклически вызывается применительно к итератору, пока мы не получим done: true;
		после каждого вызова next в теле цикла используется свойство value.

	Объекты не итерируемы, но можно написать итератор, сделав его итерируемым
	Для этого придётся пропатчить прототип Object своим методом [Symbol.iterator](). Поскольку патчинг прототипа — плохая практика, создадим свой класс, расширив Object:
		class IterableObject extends Object {
				constructor(object) {
				    super();
				    Object.assign(this, object);
				    
				    [Symbol.iterator]() {
				    	const entries = Object.entries(this);
				    	let index = -1;
				    	
				    	return {
		        	  next() {
		        	  	return {
		        	  		index++;

				            return {
				                value: entries[index],
				                done: index >= entries.length
				            }
		        	  	}
		        	  }
		     			}	
		     		}
				}
		}
		const iterableObject = new IterableObject({})
		
	После каждого вызова next нужно возвращать объект вида { value, done }
	
	
	Многие API принимают итерабельные структуры, например:
		new Map([iterable])
		new WeakMap([iterable])
		new Set([iterable])
		new WeakSet([iterable])
		Promise.all([iterable])
		Promise.race([iterable])
		Array.from([iterable])
		
		const userNamesGroupedByLocation = {}
	Чтобы сделать этот объект итерабельным, нам сначала нужно добавить функцию @@iterator. Мы можем получить доступ к этому символу через Symbol.iterator.

		userNamesGroupedByLocation[Symbol.iterator] = function() {
			// ...
		}


Генераторы:
	Генераторы - это функции, из которых можно выйти, а затем снова войти. Их контекст (привязки переменных) будет сохраняться при всех повторных входах. - MDN.
	
	Создание функции-генератора очень похоже на создание обычных функций. Все, что нам нужно сделать, это добавить звездочку (*) перед именем.
		function* sample() {
			yield "simple";
			yield "generator";
		}
		function* () {} // Анонимная функция
	yield - Мы можем добавить это ключевое слово к каждой строке, где мы хотим, чтобы итерация остановилась.
	Когда функция дойдет до конца, значение будет равно undefined, а done автоматически установится в true
	
	yield* - Если мы добавляем звездочку к ключевому слову yield, мы делегируем выполнение другому объекту-итератору.
		function* nameGenerator() {
			yield 'Iwan';
			yield 'Aiko';
		}

		function* stringGenerator() {
			yield* nameGenerator();
			yield 'hi';
		}

	Плюсы генераторо:
		Ленивая оценка
		Прямым следствием Lazy Evaluation является то, что генераторы занимают мало памяти. Генерируются только те значения, которые необходимы.
		
	Примеры использования
		циклы for, которые нужно приостановить и возобновить позже
		создание итераторов для использования в циклах for из неитерабельных объектов с помощью [Symbol.Iterator].
		
	Практические примеры:
		Вы хотите иметь бесконечный массив циклов для таких вещей, как карусели или списки данных, которые перелистываются.
		Пагинация
		Вы хотите перебирать объекты, чтобы проверить, включает ли какое-либо из их свойств определенное значение. Вы получаете массив, а затем проверяете его с помощью .includes().
	generator throttle
		Генератор уникальных идентификаторов
			function* idGenerator() {
				let i = 0;
				while (true) {
					yield i++;
				}
			}

Генераторы работают медленнее итераторов
Если вы чувствуете, что ваш код сложен и его трудно понять, если он написан иначе - используйте генераторы!


Итог:
	Хотя итераторы являются мощным инструментом, их не принято создавать так, как мы сделали в приведенном выше примере. Мы должны быть очень осторожны при программировании итераторов, поскольку ошибки могут иметь серьезные последствия, а управление внутренней логикой может быть сложным.
	Генераторы - это полезный инструмент, который позволяет нам создавать итераторы путем определения функции.
	Такой подход менее подвержен ошибкам и позволяет создавать итераторы более эффективно.
	Важной особенностью генераторов и итераторов является то, что они позволяют останавливать и продолжать выполнение по мере необходимости. 


	Генераторы - это просто способ более безопасного написания итераторов.
	Генераторы/Итераторы используются для ленивых вычислений
