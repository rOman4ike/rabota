Документ:
Браузерное окружение, спецификации:
	Сегодня JavaScript может использоваться в браузере, на веб-сервере или в какой-то другой среде, даже в кофеварке. Каждая среда предоставляет свою функциональность, которую спецификация JavaScript называет окружением.
		function sayHi() {
			alert("Hello");
		}

		// глобальные функции доступны как методы глобального объекта:
		window.sayHi();
	Окружение предоставляет свои объекты и дополнительные функции, в дополнение базовым языковым.
		1. Браузеры, например, дают средства для управления веб-страницами.
		2. Node.js делает доступными какие-то серверные возможности и так далее.

	На картинке ниже в общих чертах показано, что доступно для JavaScript в браузерном окружении:
					Window -> DOM
					|			|
					BOM		JavaScript

	DOM (Document Object Model):
		Document Object Model, сокращённо DOM – это объектная модель документа, которую браузер создает в памяти компьютера на основании HTML-кода, полученного им от сервера.
		Иными словами, это представление HTML-документа в виде дерева тегов.

		Такое дерево нужно для правильного отображения сайта и внесения изменений на страницах с помощью JavaScript.
		Пример DOM-дерева
																							_________html______
																							|									|
																							head			_______body__________
																							|					|					|					|
																							|-link		header		section		footer
																							|-meta
																							|-title

		Объект document – основная «входная точка». С его помощью мы можем что-то создавать или менять на странице.
			document.body.style.background = "red";

	BOM (Browser Object Model):
		Все объекты, через которые JavaScript взаимодействует с браузером, описываются таким понятием как Browser Object Model
		Пример BOM:
																							_________________window____________________
																							|					|					|						|						|
																							location	history		document		navigator		screen
		На вершине находится главный объект - объект window, который представляет собой браузер.

DOM-дерево:
	В соответствии с DOM, каждый HTML-тег является объектом.
	Все эти объекты доступны при помощи JavaScript, мы можем использовать их для изменения страницы.

	Пример DOM:
		Каждый узел этого дерева – это объект.
		Теги являются 'узлами-элементами': <html> – это корневой узел, <head> и <body> его дочерние узлы и т.д.
		Текст внутри элементов образует 'текстовые узлы', обозначенные как #text: в теге <p> есть текстовый узел "О лосях".
		'узел-комментарий': <!-- -->

		Все, что есть в HTML, даже комментарии, является частью DOM.

		Пробелы и переводы строки – это полноправные символы, как буквы и цифры. (пробелы убираются по краям тега)
		Существует всего два исключения из этого правила:
			1. По историческим причинам пробелы и перевод строки перед тегом <head> игнорируются
			2. Если мы записываем что-либо после закрывающего тега </body>, браузер автоматически перемещает эту запись в конец body, поскольку спецификация HTML требует,
				 чтобы всё содержимое было внутри <body>. Поэтому после закрывающего тега </body> не может быть никаких пробелов.

	Автоисправление:
		Если браузер сталкивается с некорректно написанным HTML-кодом, он автоматически корректирует его при построении DOM.
		Например, в начале документа всегда должен быть тег <html>. Даже если его нет в документе – он будет в дереве DOM, браузер его создаст. То же самое касается и тега <body>.

		Есть такой документ с незакрытыми тегами:
			<p>Привет
			<li>Мама
			<li>и
			<li>Папа
		…Но DOM будет нормальным, потому что браузер сам закроет теги и восстановит отсутствующие детали:

		ВАЖНО!
			Таблицы всегда содержат <tbody>

	Взаимодействие с консолью "ВАЖНО!"
		При работе с DOM нам часто требуется применить к нему JavaScript.
		Для начала:
			1. На вкладке Elements выберите первый элемент <li>.
			2. Нажмите Esc – прямо под вкладкой Elements откроется Console.
		Последний элемент, выбранный во вкладке Elements, доступен в консоли как $0; предыдущий, выбранный до него, как $1 и т.д.
		Теперь мы можем запускать на них команды. Например $0.style.background = 'red'

Навигация по DOM-элементам:
	Все операции с DOM начинаются с объекта document. Это главная «точка входа» в DOM. Из него мы можем получить доступ к любому узлу.

	Сверху: documentElement и body:
		<html> = document.documentElement
		<body> = document.body
		<head> = document.head

	ВАЖНО!
		Есть одна тонкость: document.body может быть равен null
		Нельзя получить доступ к элементу, которого ещё не существует в момент выполнения скрипта.

	ВАЖНО!
		В DOM значение null значит «не существует» или «нет такого узла».

	Дети: childNodes, firstChild, lastChild:
		Здесь и далее мы будем использовать два принципиально разных термина:
			'Дочерние узлы (или дети)' – элементы, которые лежат непосредственно внутри данного. Например, <head> и <body> являются детьми элемента <html>.
			'Потомки' – все элементы, которые лежат внутри данного, включая детей, их детей и т.д.
			'Соседи' – это узлы, у которых один и тот же родитель.
			'Предки элемента' – родитель, родитель родителя, его родитель и так далее.

		DOM-коллекции:
			Как мы уже видели, childNodes похож на массив. На самом деле это не массив, а коллекция – особый перебираемый объект-псевдомассив.
			И есть два важных следствия из этого:
				1. Для перебора коллекции мы можем использовать for..of:
				2. Методы массивов не будут работать, потому что коллекция – это не массив (Если мы хотим их использовать, то мы можем создать настоящий массив используя Array.from)

			ВАЖНО!
				DOM-коллекции, и даже более – все навигационные свойства, перечисленные в этой главе, доступны только для чтения.
				Мы не можем заменить один дочерний узел на другой, просто написав childNodes[i] = ...
				Для изменения DOM требуются другие методы. Мы увидим их в следующей главе.

			ВАЖНО!
				Почти все DOM-коллекции, за небольшим исключением, живые.
				Если мы сохраним ссылку на elem.childNodes и добавим/удалим узлы в DOM, то они появятся в сохранённой коллекции автоматически.

			ВАЖНО!
				Не используйте цикл for..in для перебора коллекций
				Цикл for..in перебирает все перечисляемые свойства. А у коллекций есть некоторые «лишние»

	Навигация только по элементам:
		ВАЖНО!
			Зачем нужен parentElement? Разве может родитель быть не элементом?
				alert( document.documentElement.parentNode ); // выведет document
				alert( document.documentElement.parentElement ); // выведет null
			Причина в том, что родителем корневого узла document.documentElement (<html>) является document.
			Но document - это не узел-элемент, так что parentNode вернёт его, а parentElement нет.

Поиск: getElement*, querySelector*:
	Свойства навигации по DOM хороши, когда элементы расположены рядом. А что, если нет? Как получить произвольный элемент страницы?
	Для этого в DOM есть дополнительные методы поиска.

	Также есть глобальная переменная с именем, указанным в id:
		<div id="elem">
			<div id="elem-content">Элемент</div>
		</div>

		<script>
			// elem - ссылка на элемент с id="elem"
			elem.style.background = 'red';

			// внутри id="elem-content" есть дефис, так что такой id не может служить именем переменной
			// ...но мы можем обратиться к нему через квадратные скобки: window['elem-content']
		</script>
	ВАЖНО!
		Пожалуйста, не используйте такие глобальные переменные для доступа к элементам

	ВАЖНО!
		Только document.getElementById, а не anyElem.getElementById
		Метод getElementById можно вызвать только для объекта document.

	querySelectorAll:
		ВАЖНО!
			Псевдоклассы тоже работают
			document.querySelectorAll(':hover') вернёт коллекцию (в порядке вложенности: от внешнего к внутреннему) из текущих элементов под курсором мыши.

	getElementsBy*
		Существуют также другие методы поиска элементов по тегу, классу и так далее.
		На данный момент, они скорее исторические, так как querySelector более чем эффективен.

		ВАЖНО!
			Возвращает коллекцию, а не элемент!
			Другая распространённая ошибка – написать:
				// не работает
				document.getElementsByTagName('input').value = 5;
			Попытка присвоить значение коллекции, а не элементам внутри неё, не сработает.

	Живые коллекции:
		Все методы "getElementsBy*" возвращают живую коллекцию. Такие коллекции всегда отражают текущее состояние документа и автоматически обновляются при его изменении.
		Напротив, querySelectorAll возвращает статическую коллекцию. Это похоже на фиксированный массив элементов.

Свойства узлов: тип, тег и содержимое:
	Классы DOM-узлов:
		У разных DOM-узлов могут быть разные свойства. Например, у узла, соответствующего тегу <a>, есть свойства, связанные со ссылками,
		а у соответствующего тегу <input> – свойства, связанные с полем ввода и т.д.
		Но у них есть общие свойства и методы, потому что все классы DOM-узлов образуют единую иерархию.
		Иерархия узлов - https://learn.javascript.ru/basic-dom-node-properties#klassy-dom-uzlov

		Важно!
			console.dir(elem) и console.log(elem)
			Для JavaScript-объектов эти команды обычно выводят одно и то же.
			Но для DOM-элементов они работают по-разному:
			1. console.log(elem) выводит элемент в виде DOM-дерева.
			2. console.dir(elem) выводит элемент в виде DOM-объекта, что удобно для анализа его свойств.

	Свойство «nodeType»:
		В современных скриптах, чтобы узнать тип узла, мы можем использовать метод instanceof и другие способы проверить класс, но иногда nodeType проще использовать.
		Мы не можем изменить значение nodeType, только прочитать его.

	Тег: nodeName и tagName:
		Есть ли какая-то разница между tagName и nodeName?
		Да, она отражена в названиях свойств, но не очевидна.
			1. Свойство tagName есть только у элементов Element.
			2. Свойство nodeName определено для любых узлов Node
		Другими словами, свойство tagName есть только у узлов-элементов,
		а nodeName может что-то сказать о других типах узлов.
		Если мы имеем дело только с элементами, то можно использовать tagName или nodeName, нет разницы.

	innerHTML: содержимое элемента:
		Мы также можем изменять его. Это один из самых мощных способов менять содержимое на странице.
		Мы можем попробовать вставить некорректный HTML, браузер исправит наши ошибки

		ВАЖНО!
			Скрипты не выполнятся
			Если innerHTML вставляет в документ тег <script> – он становится частью HTML, но не запускается.

		'ВАЖНО!'
			Будьте внимательны: «innerHTML+=» осуществляет перезапись
				chatDiv.innerHTML += "Как дела?";
			На практике этим следует пользоваться с большой осторожностью, так как фактически происходит не добавление, а перезапись.
			Технически эти две строки делают одно и то же:
				elem.innerHTML += "...";
				// это более короткая запись для:
				elem.innerHTML = elem.innerHTML + "..."
			'Так как содержимое «обнуляется» и переписывается заново, все изображения и другие ресурсы будут перезагружены.'

	outerHTML: HTML элемента целиком:
			<div>Привет, мир!</div>
			<script>
				let div = document.querySelector('div');
				// заменяем div.outerHTML на <p>...</p>
				div.outerHTML = '<p>Новый элемент</p>'; // (*)
				// Содержимое div осталось тем же!
				alert(div.outerHTML); // <div>Привет, мир!</div> (**)
			</script>
		Это потому, что использование outerHTML не изменяет DOM-элемент, а удаляет его из внешнего контекста и вставляет вместо него новый HTML-код.
		То есть, при div.outerHTML=... произошло следующее:
			1. div был удалён из документа.
			2. Вместо него был вставлен другой HTML <p>Новый элемент</p>.
			3. В div осталось старое значение. Новый HTML не сохранён ни в какой переменной.

Атрибуты и свойства:
	Когда браузер загружает страницу, он «читает» (также говорят: «парсит») HTML и генерирует из него DOM-объекты.
	Для узлов-элементов большинство стандартных HTML-атрибутов автоматически становятся свойствами DOM-объектов.
	Например, для такого тега <body id="page"> у DOM-объекта будет такое свойство body.id="page".
	Но преобразование атрибута в свойство происходит не один-в-один!

	DOM-свойства:
		Ранее мы уже видели встроенные DOM-свойства. Их много.
		Но технически нас никто не ограничивает, и если этого мало – мы можем добавить своё собственное свойство.
		DOM-узлы – это обычные объекты JavaScript. Мы можем их изменять.

		Итак, DOM-свойства и методы ведут себя так же, как и обычные объекты JavaScript:
			1. Им можно присвоить любое значение.
			2. Они регистрозависимы (нужно писать elem.nodeType, не elem.NoDeTyPe).

			HTML-атрибуты:
				В HTML у тегов могут быть атрибуты. Когда браузер парсит HTML, чтобы создать DOM-объекты для тегов,
				он распознаёт стандартные атрибуты и создаёт DOM-свойства для них.

				Таким образом, когда у элемента есть id или другой стандартный атрибут, создаётся соответствующее свойство.
				Но этого не происходит, если атрибут нестандартный.
					<body id="test" something="non-standard">
						<script>
							alert(document.body.id); // test
							alert(document.body.something); // undefined
						</script>
					</body>

				У HTML-атрибутов есть следующие особенности:
					Их имена регистронезависимы (id то же самое, что и ID).
					Их значения всегда являются строками.

	Синхронизация между атрибутами и свойствами:
		Когда стандартный атрибут изменяется, соответствующее свойство автоматически обновляется. Это работает и в обратную сторону (за некоторыми исключениями).
			<script>
				let input = document.querySelector('input');
				// атрибут => свойство
				input.setAttribute('id', 'id');
				alert(input.id); // id (обновлено)
				// свойство => атрибут
				input.id = 'newId';
				alert(input.getAttribute('id')); // newId (обновлено)
			</script>
		Но есть и исключения, например, input.value синхронизируется только в одну сторону – атрибут → значение

	DOM-свойства типизированы:
		DOM-свойства не всегда являются строками. Например, свойство input.checked (для чекбоксов) имеет логический тип
			alert(input.checked); // значение свойства: true
		Атрибут style – строка, но свойство style является объектом
		При этом некоторые из них, хоть и строки, могут отличаться от атрибутов. Например, DOM-свойство href всегда содержит полный URL, даже если атрибут содержит относительный URL или просто #якорь
		Если же нужно значение href или любого другого атрибута в точности, как оно записано в HTML, можно воспользоваться getAttribute

	Нестандартные атрибуты, dataset:
		Все атрибуты, начинающиеся с префикса «data-», зарезервированы для использования программистами. Они доступны в свойстве dataset.
		Пожалуйста, примите во внимание, что мы можем не только читать, но и изменять data-атрибуты. Тогда CSS обновит представление соответствующим образом

Стили и классы:
	Как правило, существует два способа задания стилей для элемента:
		1. Создать класс в CSS и использовать его: <div class="...">
		2. Писать стили непосредственно в атрибуте style: <div style="...">.
	JavaScript может менять и классы, и свойство style.
	Классы – всегда предпочтительный вариант по сравнению со style.
	Например, использование style является приемлемым, если мы вычисляем координаты элемента динамически

	Следите за единицами измерения:
		Не забудьте добавить к значениям единицы измерения.
		Например, мы должны устанавливать 10px, а не просто 10 в свойство elem.style.top. Иначе это не сработает
			document.body.style.margin = '20px';

	Вычисленные стили: getComputedStyle:
		Итак, изменить стиль очень просто. Но как его прочитать?
		Например, мы хотим знать размер, отступы, цвет элемента. Как это сделать?

Размеры и прокрутка элементов:
	Метрики:
		Вот общая картина с геометрическими свойствами: - https://learn.javascript.ru/size-and-scroll#metriki


Введение в события:
Введение в браузерные события:
	'Событие' - это сигнал от браузера о том, что что-то произошло. Все DOM-узлы подают такие сигналы (хотя события бывают и не только в DOM).

	Обработчики событий:
		Событию можно назначить 'обработчик', то есть функцию, которая сработает, как только событие произошло.

		Есть несколько способов назначить событию обработчик. Сейчас мы их рассмотрим, начиная с самого простого.
		Использование атрибута HTML:
			Обработчик может быть назначен прямо в разметке, в атрибуте, который называется on<событие>.
				<button onclick="myFunction()">Нажми меня</button>
				<script>
					function myFunction() {
						alert("Привет, мир!");
					}
				</script>
			Атрибут HTML-тега – не самое удобное место для написания большого количества кода, поэтому лучше создать отдельную JavaScript-функцию и вызвать её там.
		Использование свойства DOM-объекта:
			Можно назначать обработчик, используя свойство DOM-элемента on<событие>.
			К примеру, elem.onclick:
				<input id="elem" type="button" value="Нажми меня!">
				<script>
					elem.onclick = function() {
						alert('Спасибо');
					};
				</script>
			Обработчик всегда хранится в свойстве DOM-объекта, а атрибут – лишь один из способов его инициализации (Использование атрибута HTML == Использование свойства DOM-объекта)

			В примере ниже назначение через JavaScript перезапишет обработчик из атрибута:
			<input type="button" id="elem" onclick="alert('Было')" value="Нажми меня">
			<script>
				elem.onclick = function() { // перезапишет существующий обработчик
					alert('Станет'); // выведется только это
				};
			</script>

	Доступ к элементу через this:
		Внутри обработчика события this ссылается на текущий элемент, то есть на тот, на котором, как говорят, «висит» (т.е. назначен) обработчик.
		В коде ниже button выводит своё содержимое, используя this.innerHTML:
			<button onclick="alert(this.innerHTML)">Нажми меня</button>

	addEventListener:
		Фундаментальный недостаток описанных выше способов назначения обработчика – невозможность повесить несколько обработчиков на одно событие.
		Разработчики стандартов достаточно давно это поняли и предложили альтернативный способ назначения обработчиков при помощи специальных методов
		addEventListener и removeEventListener. Они свободны от указанного недостатка.

		'ВАЖНО!'
			Существуют события, которые нельзя назначить через DOM-свойство, но можно через addEventListener.
			Например, таково событие DOMContentLoaded, которое срабатывает, когда завершена загрузка и построение DOM документа.
				document.onDOMContentLoaded = function() {
					alert("DOM построен"); // не будет работать
				};
				document.addEventListener("DOMContentLoaded", function() {
					alert("DOM построен"); // а вот так сработает
				});

	Объект события:
		Когда происходит событие, браузер создаёт 'объект события', записывает в него детали и передаёт его в качестве аргумента функции-обработчику.
		Пример ниже демонстрирует получение координат мыши из объекта события:
			<input type="button" value="Нажми меня" id="elem">
			<script>
				elem.onclick = function(event) {
					// вывести тип события, элемент и координаты клика
					alert(event.type + " на " + event.currentTarget);
					alert("Координаты: " + event.clientX + ":" + event.clientY);
				};
			</script>

		'ВАЖНО!'
			Объект события доступен и в HTML
			При назначении обработчика в HTML, тоже можно использовать объект event, вот так:
				<input type="button" onclick="alert(event.type)" value="Тип события">
			Это возможно потому, что когда браузер из атрибута создаёт функцию-обработчик, то она выглядит так: function(event) { alert(event.type) }

	Объект-обработчик: handleEvent:
		Мы можем назначить обработчиком не только функцию, но и объект при помощи addEventListener.
		В этом случае, когда происходит событие, вызывается метод объекта handleEvent.
		К примеру:
			<button id="elem">Нажми меня</button>
			<script>
				elem.addEventListener('click', {
					handleEvent(event) {
						alert(event.type + " на " + event.currentTarget);
					}
				});
			</script>

Всплытие и погружение:
	Принцип всплытия очень простой:
		'Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков.'

	Например, есть 3 вложенных элемента FORM > DIV > P с обработчиком на каждом:
		<form onclick="alert('form')">FORM
			<div onclick="alert('div')">DIV
				<p onclick="alert('p')">P</p>
			</div>
		</form>
	Клик по внутреннему <p> вызовет обработчик onclick:
		1. Сначала на самом <p>.
		2. Потом на внешнем <div>.
		3. Затем на внешнем <form>.
	И так далее вверх по цепочке до самого document.
	Этот процесс называется 'всплытием', потому что события «всплывают» от внутреннего элемента вверх через родителей подобно тому, как всплывает пузырёк воздуха в воде.

	'ВАЖНО!'
		Почти все события всплывают.
		Ключевое слово в этой фразе – «почти».
		Например, событие focus не всплывает. В дальнейшем мы увидим и другие примеры. Однако, стоит понимать, что это скорее исключение,
		чем правило, всё-таки большинство событий всплывают.

	event.target:
		Всегда можно узнать, на каком конкретно элементе произошло событие 'Целевой элемент'.
			'Самый глубокий элемент, который вызывает событие, называется целевым элементом, и он доступен через event.target.'

		Отличия от this (=event.currentTarget):
			1. event.target – это «целевой» элемент, на котором произошло событие, в процессе всплытия он неизменен.
			2. this – это «текущий» элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик.

	Прекращение всплытия:
		Всплытие идёт с «целевого» элемента прямо наверх. По умолчанию событие будет всплывать до элемента <html>,
		а затем до объекта document, а иногда даже до window, вызывая все обработчики на своём пути.
		Например, здесь при клике на кнопку <button> обработчик body.onclick не сработает:
			<body onclick="alert(`сюда всплытие не дойдёт`)">
				<button onclick="event.stopPropagation()">Кликни меня</button>
			</body>

		'ВАЖНО!'
			Не прекращайте всплытие без необходимости!
			Всплытие - это удобно. Не прекращайте его без явной нужды, очевидной и архитектурно прозрачной.
			Зачастую нет никакой необходимости прекращать всплытие. Задача, которая, казалось бы, требует этого, может быть решена иначе.

	Погружение:
		Существует ещё одна фаза из жизненного цикла события - 'погружение' (иногда её называют «перехват»). Она очень редко используется в реальном коде,
		однако тоже может быть полезной.

		Стандарт DOM Events описывает 3 фазы прохода события:
			1. Фаза погружения (capturing phase) – событие сначала идёт сверху вниз.
			2. Фаза цели (target phase) – событие достигло целевого(исходного) элемента.
			3. Фаза всплытия (bubbling stage) – событие начинает всплывать.

		Ранее мы говорили только о всплытии, потому что другие стадии, как правило, не используются и проходят незаметно для нас.

		Обработчики, добавленные через on<event>-свойство или через HTML-атрибуты, или через addEventListener(event, handler) с двумя аргументами,
		ничего не знают о фазе погружения, а работают только на 2-ой и 3-ей фазах.

		Чтобы поймать событие на стадии погружения, нужно использовать третий аргумент capture вот так:
			// false (по умолчанию), то событие будет поймано при всплытии, true, то событие будет перехвачено при погружении.
			elem.addEventListener(..., {capture: true})
			// или просто "true", как сокращение для {capture: true}
			elem.addEventListener(..., true)

		Если вы кликните по <p>, то последовательность следующая:
			1. HTML → BODY → FORM → DIV (фаза погружения, первый обработчик)
			2. P (фаза цели, срабатывают обработчики, установленные и на погружение и на всплытие, так что выведется два раза)
			3. DIV → FORM → BODY → HTML (фаза всплытия, второй обработчик)

		Существует свойство 'event.eventPhase', содержащее номер фазы, на которой событие было поймано.

		'ВАЖНО!'
			Чтобы убрать обработчик removeEventListener, нужна та же фаза
			Если мы добавили обработчик вот так addEventListener(..., true), то мы должны передать то же значение аргумента
			capture в removeEventListener(..., true), когда снимаем обработчик.

		'ВАЖНО!'
			Если у нас несколько обработчиков одного события, назначенных addEventListener на один элемент, в рамках одной фазы, то их порядок срабатывания – тот же, в котором они установлены:
				elem.addEventListener("click", e => alert(1)); // всегда сработает перед следующим
				elem.addEventListener("click", e => alert(2));

Делегирование событий:
	Всплытие и перехват событий позволяет реализовать один из самых важных приёмов разработки – 'делегирование'.
	Идея в том, что если у нас есть много элементов, события на которых нужно обрабатывать похожим образом, то вместо того,
	чтобы назначать обработчик каждому, мы ставим один обработчик на их общего предка.
	Из него можно получить целевой элемент event.target, понять на каком именно потомке произошло событие и обработать его.
	Пример - диаграмма Ба-Гуа: https://learn.javascript.ru/event-delegation

	Примеры делегирования (не стал разбирать потому что а нахуя?)):
		https://learn.javascript.ru/event-delegation#primenenie-delegirovaniya-deystviya-v-razmetke

Действия браузера по умолчанию:
	Многие события автоматически влекут за собой действие браузера.
	Например:
		1. Клик по ссылке инициирует переход на новый URL.
		2. Нажатие на кнопку «отправить» в форме – отсылку её на сервер.
		3. Зажатие кнопки мыши над текстом и её движение в таком состоянии – инициирует его выделение.
	Если мы обрабатываем событие в JavaScript, то зачастую такое действие браузера нам не нужно. К счастью, его можно отменить.

	Отмена действия браузера
		Есть два способа отменить действие браузера:
			1. Основной способ – это воспользоваться объектом event. Для отмены действия браузера существует стандартный метод event.preventDefault().
			2. Если же обработчик назначен через on<событие> (не через addEventListener), то также можно вернуть false из обработчика.

		'ВАЖНО!'
			Возвращать true не нужно
			Обычно значение, которое возвращает обработчик события, игнорируется.
			Единственное исключение – это return false

		'ВАЖНО!'
			Некоторые события естественным образом вытекают друг из друга. Если мы отменим первое событие, то последующие не возникнут.
			Например, событие mousedown для поля <input> приводит к фокусировке на нём и запускает событие focus. Если мы отменим событие mousedown, то фокусирования не произойдёт.
				<input onmousedown="return false" onfocus="this.value=''" value="Кликни меня">

	Опция «passive» для обработчика
		Необязательная опция passive: true для addEventListener сигнализирует браузеру, что обработчик не собирается выполнять preventDefault().

	event.defaultPrevented:
		Свойство event.defaultPrevented установлено в true, если действие по умолчанию было предотвращено, и false, если нет.

Генерация пользовательских событий:
	Можно не только назначать обработчики, но и генерировать события из JavaScript-кода.
	Можно генерировать не только совершенно новые, придуманные нами события, но и встроенные, такие как click, mousedown и другие.

	Конструктор Event:
		Событие встроенного класса Event можно создать так:
			let event = new Event(type[, options]);
		Где:
			1. type – тип события, строка, например "click" или же любой придуманный нами – "my-event".
			2. options – объект с тремя необязательными свойствами:
				1. bubbles: true/false – если true, тогда событие всплывает.
				2. cancelable: true/false – если true, тогда можно отменить действие по умолчанию. Позже мы разберём, что это значит для пользовательских событий.
				3. composed: true/false – если true, тогда событие будет всплывать наружу за пределы Shadow DOM. Позже мы разберём это в разделе Веб-компоненты.
		По умолчанию все три свойства установлены в false

	Метод dispatchEvent
		После того, как объект события создан, мы должны запустить его на элементе, вызвав метод elem.dispatchEvent(event).
		Затем обработчики отреагируют на него, как будто это обычное браузерное событие.

		'ВАЖНО!'
			event.isTrusted
			Можно легко отличить «настоящее» событие от сгенерированного кодом.
			Свойство event.isTrusted принимает значение true для событий, порождаемых реальными действиями пользователя, и false для генерируемых кодом.

	MouseEvent, KeyboardEvent и другие:
		Для некоторых конкретных типов событий есть свои специфические конструкторы.
		Вот небольшой список конструкторов для различных событий пользовательского интерфейса, которые можно найти в спецификации UI Event:
			UIEvent
			FocusEvent
			MouseEvent
			WheelEvent
			KeyboardEvent
			…
		Например, clientX/clientY для события мыши:
			let event = new MouseEvent("click", {
				bubbles: true,
				cancelable: true,
				clientX: 100,
				clientY: 100
			});

	Пользовательские события:
		Для генерации событий совершенно новых типов, таких как "hello", следует использовать конструктор new CustomEvent. Технически CustomEvent абсолютно идентичен Event за исключением одной небольшой детали.
		У второго аргумента-объекта есть дополнительное свойство detail, в котором можно указывать информацию для передачи в событие.
		Например:
			<h1 id="elem">Привет для Васи!</h1>
			<script>
				// дополнительная информация приходит в обработчик вместе с событием
				elem.addEventListener("hello", function(event) {
					alert(event.detail.name);
				});
				elem.dispatchEvent(new CustomEvent("hello", {
					detail: { name: "Вася" }
				}));
			</script>
		Свойство detail может содержать любые данные.

	event.preventDefault():
		Вызов event.preventDefault() является возможностью для обработчика события сообщить в сгенерировавший событие код, что эти действия надо отменить.
		Тогда вызов elem.dispatchEvent(event) возвратит false. И код, сгенерировавший событие, узнает, что продолжать не нужно.

		'ВАЖНО!'
			Обратите внимание: событие должно содержать флаг cancelable: true. Иначе, вызов event.preventDefault() будет проигнорирован.
				let event = new CustomEvent("hide", {
					cancelable: true // без этого флага preventDefault не сработает
				})

	Вложенные события обрабатываются синхронно:
		Обычно события обрабатываются асинхронно.
		Исключением является ситуация, когда событие инициировано из обработчика другого события.
		Тогда управление сначала переходит в обработчик вложенного события и уже после этого возвращается назад.

		В примере ниже событие menu-open обрабатывается синхронно во время обработки onclick:
			<button id="menu">Меню (нажми меня)</button>
			<script>
				menu.onclick = function() {
					alert(1);
					// alert("вложенное событие")
					menu.dispatchEvent(new CustomEvent("menu-open", {
						bubbles: true
					}));
					alert(2);
				};
				document.addEventListener('menu-open', () => alert('вложенное событие'))
			</script>
		Порядок вывода: 1 → вложенное событие → 2.


Интерфейсные события:
Основы событий мыши:
	Сразу заметим: эти события бывают не только из-за мыши, но и эмулируются на других устройствах, в частности, на мобильных, для совместимости.

	Порядок событий:
		В случае, когда одно действие инициирует несколько событий, порядок их выполнения фиксирован.
		То есть обработчики событий вызываются в следующем порядке: mousedown → mouseup → click.

	Кнопки мыши
		События, связанные с кликом, всегда имеют свойство button, которое позволяет получить конкретную кнопку мыши.
		Обработчикам mousedown и mouseup может потребоваться 'event.button', потому что эти события срабатывают на любую кнопку, таким образом button позволяет различать «нажатие правой кнопки» и «нажатие левой кнопки».

		Состояние кнопки						event.button
		Левая кнопка 								(основная)	0
		Средняя кнопка 							(вспомогательная)	1
		Правая кнопка 							(вторичная)	2

		'ВАЖНО!'
			В старом коде вы можете встретить 'event.which' свойство – это старый нестандартный способ получения кнопки с возможными значениями:
				event.which == 1 – левая кнопка,
				event.which == 2 – средняя кнопка,
				event.which == 3 – правая кнопка.
			На данный момент event.which устарел, нам не следует его использовать.

	Модификаторы: shift, alt, ctrl и meta:
		Все события мыши включают в себя информацию о нажатых клавишах-модификаторах.
		Свойства события:
			shiftKey: Shift
			altKey: Alt (или Opt для Mac)
			ctrlKey: Ctrl
			metaKey: Cmd для Mac
		Они равны true, если во время события была нажата соответствующая клавиша.
		(event.shiftKey, event.altKey, event.metaKey)

		'ВАЖНО!'
			Внимание: обычно на Mac используется клавиша Cmd вместо Ctrl

		'ВАЖНО!'
			Не забывайте про мобильные устройства
			Комбинации клавиш хороши в качестве дополнения к рабочему процессу. Так что, если посетитель использует клавиатуру – они работают.
			Но если на их устройстве его нет – тогда должен быть способ жить без клавиш-модификаторов.

	Отключаем выделение:
		Двойной клик мыши имеет побочный эффект, который может быть неудобен в некоторых интерфейсах: он выделяет текст.
		Есть несколько способов запретить выделение, о которых вы можете прочитать в главе Selection и Range.

		В данном случае самым разумным будет отменить действие браузера по умолчанию при событии:
			<b ondblclick="alert('Клик!')" onmousedown="return false">
				asdfasfd
			</>

		'ВАЖНО!'
			Если мы хотим отключить выделение для защиты содержимого страницы от копирования, то мы можем использовать другое событие: oncopy
				<div oncopy="alert('Копирование запрещено!');return false">
					Уважаемый пользователь,
				</div>
			Конечно, пользователь имеет доступ к HTML-коду страницы и может взять текст оттуда, но не все знают, как это сделать.

Движение мыши: mouseover/out, mouseenter/leave:
	События mouseover/mouseout, relatedTarget:
		Событие mouseover происходит в момент, когда курсор оказывается над элементом, а событие mouseout – в момент, когда курсор уходит с элемента.
		Эти события являются особенными, потому что у них имеется свойство 'relatedTarget'. Оно «дополняет» target.
		Когда мышь переходит с одного элемента на другой, то один из них будет 'target', а другой 'relatedTarget'.

		Для события mouseover:
			event.target – это элемент, на который курсор перешёл.
			event.relatedTarget – это элемент, с которого курсор ушёл (relatedTarget → target).
		Для события mouseout наоборот:
			event.target – это элемент, с которого курсор ушёл.
			event.relatedTarget – это элемент, на который курсор перешёл (target → relatedTarget).

		'ВАЖНО!'
			Свойство relatedTarget может быть null.
			Это нормально и означает, что указатель мыши перешёл не с другого элемента, а из-за пределов окна браузера. Или же, наоборот, ушёл за пределы окна.

	Пропуск элементов:
		Событие mousemove происходит при движении мыши. Однако, это не означает, что указанное событие генерируется при прохождении каждого пикселя.
		Браузер периодически проверяет позицию курсора и, заметив изменения, генерирует события mousemove.

		Если курсор мыши передвинуть очень быстро с одного элемента на другой, то лежащие между ними элементы <div> (или некоторые из них) могут быть пропущены.

		'ВАЖНО!'
			Если был mouseover, то будет и mouseout
			Если указатель «официально» зашёл на элемент, то есть было событие mouseover, то при выходе с него обязательно будет mouseout.

	Событие mouseout при переходе на потомка:
		Важная особенность события mouseout – оно генерируется в том числе, когда указатель переходит с элемента на его потомка.
		То есть, визуально указатель всё ещё на элементе, но мы получим mouseout!
		Событие mouseover, происходящее на потомке, всплывает. Поэтому если на родительском элементе есть такой обработчик, то оно его вызовет.

	События mouseenter и mouseleave
		События mouseenter/mouseleave похожи на mouseover/mouseout. Они тоже генерируются, когда курсор мыши переходит на элемент или покидает его.
		Но есть и пара важных отличий:
			1. Переходы внутри элемента, на его потомки и с них, не считаются.
			2. События mouseenter/mouseleave не всплывают.

	Делегирование событий:
		События mouseenter/leave просты и легки в использовании. Но они не всплывают. Таким образом, мы не можем их делегировать.

Drag'n'Drop с событиями мыши:
	Но у них есть и ограничения. Например, нельзя организовать перенос «только по горизонтали» или «только по вертикали».
	Также нельзя ограничить перенос внутри заданной зоны.
	Есть и другие интерфейсные задачи, которые такими встроенными событиями не реализуемы.
	Кроме того, мобильные устройства плохо их поддерживают.

	Алгоритм Drag’n’Drop:
	Базовый алгоритм Drag’n’Drop выглядит так:
		1. При mousedown – готовим элемент к перемещению, если необходимо (например, создаём его копию).
		2. Затем при mousemove передвигаем элемент на новые координаты путём смены left/top и position:absolute.
		3. При mouseup – остановить перенос элемента и произвести все действия, связанные с окончанием Drag’n’Drop.

	Цели переноса (droppable):
		В предыдущих примерах мяч можно было бросить просто где угодно в пределах окна.
		В реальности мы обычно берём один элемент и перетаскиваем в другой. Например, «файл» в «папку» или что-то ещё.

		Абстрактно говоря, мы берём перетаскиваемый (draggable) элемент и помещаем его в другой элемент «цель переноса» (droppable).

		Так что же делать?
		Существует метод 'document.elementFromPoint(clientX, clientY)'.
		Он возвращает наиболее глубоко вложенный элемент по заданным координатам окна (или null, если указанные координаты находятся за пределами окна).

Клавиатура: keydown и keyup
	Прежде чем перейти к клавиатуре, обратите внимание, что на современных устройствах есть и другие способы «ввести что-то».
	Например, распознавание речи (это особенно актуально на мобильных устройствах) или Копировать/Вставить с помощью мыши.

	Поэтому, если мы хотим корректно отслеживать ввод в поле <input>, то одних клавиатурных событий недостаточно.
	Существует специальное событие 'input', чтобы отслеживать любые изменения в поле <input>. И оно справляется с такой задачей намного лучше.

	События клавиатуры же должны использоваться, если мы хотим обрабатывать взаимодействие пользователя именно с клавиатурой (в том числе виртуальной).
	К примеру, если нам нужно реагировать на стрелочные клавиши Up и Down или горячие клавиши (включая комбинации клавиш).

	События keydown и keyup:
		Событие 'keydown' происходит при нажатии клавиши, а 'keyup' – при отпускании.

		event.code и event.key:
			Свойство 'key' объекта события позволяет получить символ, а свойство 'code' – «физический код клавиши».

			К примеру, одну и ту же клавишу Z можно нажать с клавишей Shift и без неё. В результате получится два разных символа: z в нижнем регистре и Z в верхнем регистре.
			Свойство event.key – это непосредственно символ, и он может различаться. Но event.code всегда будет тот же

			Если пользователь работает с разными языками, то при переключении на другой язык символ изменится с "Z" на совершенно другой.
			Получившееся станет новым значением event.key, тогда как event.code останется тем же: "KeyZ".

			С другой стороны, с event.code тоже есть проблемы. На разных раскладках к одной и той же клавише могут быть привязаны разные символы.
			Чтобы отслеживать символы, зависящие от раскладки, event.key надёжнее.
			С другой стороны, преимущество event.code заключается в том, что его значение всегда остаётся неизменным, будучи привязанным к физическому местоположению клавиши, даже если пользователь меняет язык.

			'ВАЖНО!'
				Хотим поддерживать клавиши, меняющиеся при раскладке? Тогда event.key – верный выбор.
				Или мы хотим, чтобы горячая клавиша срабатывала даже после переключения на другой язык? Тогда event.code может быть лучше.

	Автоповтор:
		При долгом нажатии клавиши возникает автоповтор: keydown срабатывает снова и снова, и когда клавишу отпускают, то отрабатывает keyup.
		Так что ситуация, когда много keydownи один keyup, абсолютно нормальна.

		Для событий, вызванных автоповтором, у объекта события свойство 'event.repeat' равно true.

	Действия по умолчанию:
		Действия по умолчанию весьма разнообразны, много чего можно инициировать нажатием на клавиатуре.
		Для примера:
			1. Появление символа (самое очевидное).
			2. Удаление символа (клавиша Delete).
			3. Прокрутка страницы (клавиша PageDown).
			4. Открытие диалогового окна браузера «Сохранить» (Ctrl+S)
			4. …и так далее.
		Предотвращение стандартного действия с помощью event.preventDefault() работает практически во всех сценариях, кроме тех,
		которые происходят на уровне операционной системы. Например, комбинация Alt+F4 инициирует закрытие браузера в Windows, что бы мы ни делали в JavaScript.

	«Дела минувших дней»:
		В прошлом существовало также событие keypress, а также свойства keyCode, charCode, which у объекта события.
		Но количество браузерных несовместимостей при работе с ними было столь велико, что у разработчиков спецификации не было другого выхода,
		кроме как объявить их устаревшими и создать новые

События указателя:
	'События указателя (Pointer events)' – это современный способ обработки ввода с помощью различных указывающих устройств, таких как мышь,
		перо/стилус, сенсорный экран и так далее.

		Если вы не разрабатываете под старые браузеры, такие как Internet Explorer 10, Safari 12, или более ранние версии,
		больше нет необходимости использовать события мыши или касаний – можно переходить сразу на события указателя.

	Типы событий указателя
		Схема именований событий указателя похожа на события мыши:

		Событие указателя					|			Аналогичное событие мыши
		--------------------------------------------------------
		pointerdown	        			|			mousedown
		pointerup	          			|			mouseup
		pointermove	        			|			mousemove
		pointerover	        			|			mouseover
		pointerout	        			|			mouseout
		pointerenter	      			|			mouseenter
		pointerleave	      			|			mouseleave
		pointercancel	      			|			-
		gotpointercapture	  			|			-
		lostpointercapture				|			-

		'ВАЖНО!'
			Замена mouse<событий> на pointer<события> в коде
			Мы можем заменить события mouse... на аналогичные pointer... в коде и быть уверенными, что с мышью по-прежнему всё будет работать нормально.
			При этом поддержка сенсорных устройств «волшебным» образом улучшится. Хотя, возможно, кое-где понадобится добавить touch-action: none в CSS.

	Свойства событий указателя:
		События указателя содержат те же свойства, что и события мыши, например clientX/Y, target и т.п., и несколько дополнительных:
			1. pointerId – уникальный идентификатор указателя, вызвавшего событие.
				Идентификатор генерируется браузером. Это свойство позволяет обрабатывать несколько указателей, например сенсорный экран со стилусом и мульти-тач (увидим примеры ниже).
			2. pointerType – тип указывающего устройства. Должен быть строкой с одним из значений: «mouse», «pen» или «touch».
				Мы можем использовать это свойство, чтобы определять разное поведение для разных типов указателей.
			3. isPrimary – равно true для основного указателя (первый палец в мульти-тач).

		Некоторые устройства измеряют область контакта и степень надавливания, например пальца на сенсорном экране, для этого есть дополнительные свойства:
		(width, height, pressure, tangetialPressure, tiltX, tiltY, twist)

	Мульти-тач
		Одной из функций, которую абсолютно не поддерживают события мыши, является 'мульти-тач':
		возможность касаться сразу нескольких мест на телефоне или планшете или выполнять специальные жесты.
		Вот что происходит, когда пользователь касается сенсорного экрана в одном месте, а затем в другом:
			1. При касании первым пальцем:
					происходит событие pointerdown со свойством isPrimary=true и некоторым pointerId.
			2. При касании вторым и последующими пальцами (при остающемся первом):
					происходит событие pointerdown со свойством isPrimary=false и уникальным pointerId для каждого касания.

	Событие: pointercancel
		Событие pointercancel происходит, когда текущее действие с указателем по какой-то причине прерывается, и события указателя больше не генерируются.
		К таким причинам можно отнести:
			1. Указывающее устройство было физически выключено.
			2. Изменилась ориентация устройства (перевернули планшет).
			3. Браузер решил сам обработать действие, считая его жестом мыши, масштабированием и т.п.

	Захват указателя
		'Захват указателя' – особая возможность событий указателя.

		Общая идея очень проста, но поначалу может показаться странной, так как для других событий ничего подобного просто нет.
		Основной метод:
			'elem.setPointerCapture(pointerId)' – привязывает события с данным pointerId к elem. После такого вызова все события указателя с таким pointerId будут иметь elem в качестве целевого элемента (как будто произошли над elem), вне зависимости от того, где в документе они произошли.
		Другими словами, elem.setPointerCapture(pointerId) меняет target всех дальнейших событий с данным pointerId на elem.

		Эта привязка отменяется:
			1. автоматически, при возникновении события pointerup или pointercancel,
			2. автоматически, если elem удаляется из документа,
			3.при вызове elem.releasePointerCapture(pointerId).
		Захват указателя используется для упрощения операций с переносом (drag’n’drop) элементов.

Прокрутка
	Событие прокрутки scroll позволяет реагировать на прокрутку страницы или элемента.

	Предотвращение прокрутки:
		Как можно сделать что-то непрокручиваемым?

		Нельзя предотвратить прокрутку, используя event.preventDefault() в обработчике onscroll, потому что он срабатывает после того, как прокрутка уже произошла.
		Но можно предотвратить прокрутку, используя event.preventDefault() на событии, которое вызывает прокрутку, например, на событии keydown для клавиш pageUp и pageDown.

		Способов инициировать прокрутку много, поэтому более надёжный способ – использовать CSS, свойство overflow.

Формы, элементы управления:
Свойства и методы формы:
	Формы и элементы управления, такие как <input>, имеют множество специальных свойств и событий.
	Навигация: формы и элементы
		Формы в документе входят в специальную коллекцию 'document.forms'.
		Это так называемая «именованная» коллекция: мы можем использовать для получения формы как её имя, так и порядковый номер в документе.

		Может быть несколько элементов с одним и тем же именем, это часто бывает с кнопками-переключателями radio.
		В этом случае form.elements[name] является коллекцией, например

		'ВАЖНО!'
			Форма может содержать один или несколько элементов <fieldset> внутри себя.
			Они также поддерживают свойство elements, в котором находятся элементы управления внутри них.

		'ВАЖНО!'
			Сокращённая форма записи: form.name
			Есть более короткая запись: мы можем получить доступ к элементу через form[index/name].
			Другими словами, вместо form.elements.login мы можем написать form.login.

			Это также работает, но есть небольшая проблема: если мы получаем элемент, а затем меняем его свойство name, то он всё ещё будет доступен под старым именем (также, как и под новым).
				<form id="form">
					<input name="login">
				</form>
				<script>
					alert(form.elements.login == form.login); // true, ведь это одинаковые <input>
					form.login.name = "username"; // изменяем свойство name у элемента input
					// form.elements обновили свои имена:
					alert(form.elements.login); // undefined
					alert(form.elements.username); // input
					// а в form мы можем использовать оба имени: новое и старое
					alert(form.username == form.login); // true
				</script>

	Обратная ссылка: element.form
		Для любого элемента форма доступна через element.form. Так что форма ссылается на все элементы, а эти элементы ссылаются на форму.
			<form id="form">
				<input type="text" name="login">
			</form>
			<script>
				// form -> element
				let login = form.login;
				// element -> form
				alert(login.form); // HTMLFormElement
			</script>

	Элементы формы:
		input и textarea
			К их значению можно получить доступ через свойство 'input.value' (строка) или 'input.checked' (булево значение) для чекбоксов.

			'ВАЖНО!'
				Используйте textarea.value вместо textarea.innerHTML
				innerHTML Там хранится только тот HTML, который был изначально на странице, а не текущее значение.

		select и option
			Элемент <select> имеет 3 важных свойства:
				1. select.options – коллекция из подэлементов <option>,
				2. select.value – значение выбранного в данный момент <option>,
				3. select.selectedIndex – номер выбранного <option>.
			Они дают три разных способа установить значение в <select>:
				1. Найти соответствующий элемент <option> и установить в option.selected значение true.
				2. Установить в select.value значение нужного <option>.
				3. Установить в select.selectedIndex номер нужного <option>.

		new Option
			Элемент <option> редко используется сам по себе, но и здесь есть кое-что интересное.
			В спецификации есть красивый короткий синтаксис для создания элемента <option>:
				option = new Option(text, value, defaultSelected, selected);
			Параметры:
				1. text – текст внутри <option>,
				2. value – значение,
				3. defaultSelected – если true, то ставится HTML-атрибут selected,
				4. selected – если true, то элемент <option> будет выбранным.

Фокусировка: focus/blur:
	Элемент получает фокус, когда пользователь кликает по нему или использует клавишу Tab.
	Также существует HTML-атрибут autofocus, который устанавливает фокус на элемент, когда страница загружается.
	Есть и другие способы получения фокуса, о них – далее.

	Фокусировка обычно означает: «приготовься к вводу данных на этом элементе», это хороший момент, чтобы инициализовать или загрузить что-нибудь.
	Потеря фокуса обычно означает «данные введены», и мы можем выполнить проверку введённых данных или даже отправить эти данные на сервер и так далее.

	События focus/blur:
		Событие 'focus' вызывается в момент фокусировки, а 'blur' – когда элемент теряет фокус.

	Методы focus/blur
		Методы 'elem.focus()' и 'elem.blur()' устанавливают/снимают фокус.

		Отметим, что мы не можем «отменить потерю фокуса», вызвав event.preventDefault() в обработчике onblur потому,
		что onblur срабатывает после потери фокуса элементом.

		'ВАЖНО!'
			Потеря фокуса может произойти по множеству причин.
			Одна из них – когда посетитель кликает куда-то ещё. Но и JavaScript может быть причиной, например:
				1. alert переводит фокус на себя – элемент теряет фокус (событие blur), а когда alert закрывается – элемент получает фокус обратно (событие focus).
				2. Если элемент удалить из DOM, фокус также будет потерян. Если элемент добавить обратно, то фокус не вернётся.

	Включаем фокусировку на любом элементе: tabindex:
		Многие элементы по умолчанию не поддерживают фокусировку.
		Какие именно – зависит от браузера, но одно всегда верно: поддержка focus/blur гарантирована для элементов, с
		которыми посетитель может взаимодействовать: <button>, <input>, <select>, <a> и т.д.

		Это можно изменить HTML-атрибутом 'tabindex'.
			<ul>
				<li tabindex="1">Один</li>
				<li tabindex="0">Ноль</li>
				<li tabindex="2">Два</li>
				<li tabindex="-1">Минус один</li>
			</ul>
		Значение этого атрибута – порядковый номер элемента, когда клавиша Tab (или что-то аналогичное) используется для переключения между элементами.

		Есть два специальных значения:
			1. tabindex="0" ставит элемент в один ряд с элементами без tabindex. То есть, при переключении такие элементы будут после элементов с tabindex ≥ 1.
				Обычно используется, чтобы включить фокусировку на элементе, но не менять порядок переключения.
				Чтобы элемент мог участвовать в форме наравне с обычными <input>.
				Порядок такой: 1 - 2 - 0
			2. tabindex="-1" позволяет фокусироваться на элементе только программно. Клавиша Tab проигнорирует такой элемент, но метод elem.focus() будет действовать.

		'ВАЖНО!'
			Свойство 'elem.tabIndex' тоже работает
			Мы можем добавить tabindex из JavaScript, используя свойство elem.tabIndex. Это даст тот же эффект.

	События focusin/focusout:
		События focus и blur не всплывают.
		У этой проблемы два решения.
			1. Первое: забавная особенность – focus/blur не всплывают, но передаются вниз на фазе перехвата.
				Это сработает:
					<form id="form">
						<input type="text" name="name" value="Имя">
						<input type="text" name="surname" value="Фамилия">
					</form>
					<style> .focused { outline: 1px solid red; } </style>
					<script>
						// установить обработчик на фазе перехвата (последний аргумент true)
						form.addEventListener("focus", () => form.classList.add('focused'), true);
						form.addEventListener("blur", () => form.classList.remove('focused'), true);
					</script>

			2. Второе решение: события 'focusin' и 'focusout' – такие же, как и focus/blur, но они всплывают.

События: change, input, cut, copy, paste:
	Событие: change
		Событие 'change' срабатывает по окончании изменения элемента.

		Для текстовых <input> это означает, что событие происходит при потере фокуса.
		Для других элементов: select, input type=checkbox/radio событие запускается сразу после изменения значения

	Событие: input:
		Событие 'input' срабатывает каждый раз при изменении значения.

		В отличие от событий клавиатуры, оно работает при любых изменениях значений, даже если они не связаны с клавиатурными действиями:
		вставка с помощью мыши или распознавание речи при диктовке текста.

		'ВАЖНО!'
			Нельзя ничего предотвратить в oninput
			Событие input происходит после изменения значения.
			Поэтому мы не можем использовать event.preventDefault() там – будет уже слишком поздно, никакого эффекта не будет.

События: cut, copy, paste:
	Эти события происходят при вырезании/копировании/вставке данных.
	Мы также можем использовать event.preventDefault() для предотвращения действия по умолчанию, и в итоге ничего не скопируется/не вставится.

Отправка формы: событие и метод submit
	При отправке формы срабатывает событие 'submit', оно обычно используется для проверки (валидации) формы перед её отправкой на
	сервер или для предотвращения отправки и обработки её с помощью JavaScript.
	Метод 'form.submit()' позволяет инициировать отправку формы из JavaScript.

	Событие: submit
		Есть два основных способа отправить форму:
			1. Первый – нажать кнопку <input type="submit"> или <input type="image">.
			2. Второй – нажать Enter, находясь на каком-нибудь поле.
		Оба действия сгенерируют событие submit на форме.

		Обработчик может проверить данные, и если есть ошибки, показать их и вызвать event.preventDefault(), тогда форма не будет отправлена на сервер.

		'ВАЖНО!'
			Взаимосвязь между submit и click
			При отправке формы по нажатию Enter в текстовом поле, генерируется событие click на кнопке <input type="submit">.
			Это довольно забавно, учитывая что никакого клика не было.

Загрузка документа и ресурсов:
	У жизненного цикла HTML-страницы есть три важных события:
		1. DOMContentLoaded – браузер полностью загрузил HTML, было построено DOM-дерево, но внешние ресурсы, такие как картинки <img> и стили, могут быть ещё не загружены.
		2. load – браузер загрузил HTML и внешние ресурсы (картинки, стили и т.д.).
		3. beforeunload/unload – пользователь покидает страницу.
	Каждое из этих событий может быть полезно:
		1. Событие DOMContentLoaded – DOM готов, так что обработчик может искать DOM-узлы и инициализировать интерфейс.
		2. Событие load – внешние ресурсы были загружены, стили применены, размеры картинок известны и т.д.
		3. Событие beforeunload – пользователь покидает страницу. Мы можем проверить, сохранил ли он изменения и спросить, на самом ли деле он хочет уйти.
		4. unload – пользователь почти ушёл, но мы всё ещё можем запустить некоторые операции, например, отправить статистику.

	'document.addEventListener("DOMContentLoaded", ready);'
	// не "document.onDOMContentLoaded = ..."

	DOMContentLoaded и скрипты
		Когда браузер обрабатывает HTML-документ и встречает тег <script>, он должен выполнить его перед тем, как продолжить строить DOM.
		Это делается на случай, если скрипт захочет изменить DOM или даже дописать в него (document.write), так что DOMContentLoaded должен подождать.

		'ВАЖНО!'
			Есть два исключения из этого правила:
				1. Скрипты с атрибутом async, который мы рассмотрим немного позже, не блокируют DOMContentLoaded.
				2. Скрипты, сгенерированные динамически при помощи document.createElement('script') и затем добавленные на страницу, также не блокируют это событие.

		DOMContentLoaded и стили
			Внешние таблицы стилей не затрагивают DOM, поэтому DOMContentLoaded их не ждёт.
			Но здесь есть подводный камень. Если после стилей у нас есть скрипт, то этот скрипт должен дождаться, пока загрузятся стили:

			Встроенное в браузер автозаполнение
				Firefox, Chrome и Opera автоматически заполняют поля при наступлении DOMContentLoaded.
				Например, если на странице есть форма логина и пароля и браузер запомнил значения, то при наступлении DOMContentLoaded
				он попытается заполнить их (если получил разрешение от пользователя).

				Так что, если DOMContentLoaded откладывается из-за долгой загрузки скриптов, в свою очередь – откладывается автозаполнение.

	window.onunload
		Обычно здесь отсылают статистику.
		Предположим, мы собрали данные о том, как используется страница: клики, прокрутка, просмотры областей страницы и так далее.
		Естественно, событие unload – это тот момент, когда пользователь нас покидает и мы хотим сохранить эти данные.
		Для этого существует специальный метод 'navigator.sendBeacon(url, data)', описанный в спецификации https://w3c.github.io/beacon/.
		Он посылает данные в фоне. Переход к другой странице не задерживается: браузер покидает страницу, но всё равно выполняет sendBeacon.

		Его можно использовать вот так:
			let analyticsData = { /* объект с собранными данными */ };
			window.addEventListener("unload", function() {
				navigator.sendBeacon("/analytics", JSON.stringify(analyticsData));
			});
		1. Отсылается POST-запрос.
		2. Мы можем послать не только строку, но так же формы и другие форматы, как описано в главе Fetch, но обычно это строковый объект.
		3. Размер данных ограничен 64 Кб.

	window.onbeforeunload
		Если посетитель собирается уйти со страницы или закрыть окно, обработчик beforeunload попросит дополнительное подтверждение.

	readyState
		Что произойдёт, если мы установим обработчик DOMContentLoaded после того, как документ загрузился?
		Естественно, он никогда не запустится.

		Есть случаи, когда мы не уверены, готов документ или нет. Мы бы хотели, чтобы наша функция исполнилась, когда DOM загрузился, будь то сейчас или позже.
		Свойство 'document.readyState' показывает нам текущее состояние загрузки.
		Есть три возможных значения:
			1. "loading" – документ загружается.
			2. "interactive" – документ был полностью прочитан.
			3. "complete" – документ был полностью прочитан и все ресурсы (такие как изображения) были тоже загружены.
		Также есть событие 'readystatechange', которое генерируется при изменении состояния, так что мы можем вывести все эти состояния таким образом:
		Типичный вывод:
			[1] начальный readyState:loading
			[2] readyState:interactive
			[2] DOMContentLoaded
			[3] iframe onload
			[4] img onload
			[4] readyState:complete
			[4] window onload

Скрипты: async, defer:
	В современных сайтах скрипты обычно «тяжелее», чем HTML: они весят больше, дольше обрабатываются.
	Когда браузер загружает HTML и доходит до тега <script>...</script>, он не может продолжать строить DOM.
	Он должен сначала выполнить скрипт. То же самое происходит и с внешними скриптами <script src="..."></script>

	Это ведёт к двум важным проблемам:
		1. Скрипты не видят DOM-элементы ниже себя, поэтому к ним нельзя добавить обработчики и т.д.
		2. Если вверху страницы объёмный скрипт, он «блокирует» страницу. Пользователи не видят содержимое страницы, пока он не загрузится и не запустится:

	Конечно, есть пути, как это обойти. Например, мы можем поместить скрипт внизу страницы.
	Но это решение далеко от идеального. Например, браузер замечает скрипт (и может начать загружать его) только после того, как он полностью загрузил HTML-документ.
	В случае с длинными HTML-страницами это может создать заметную задержку.

	К счастью, есть два атрибута тега <script>, которые решают нашу проблему: defer и async.

	defer:
		Атрибут defer сообщает браузеру, что он должен продолжать обрабатывать страницу и загружать скрипт в фоновом режиме,
		а затем запустить этот скрипт, когда DOM дерево будет полностью построено.
			1. Скрипты с defer никогда не блокируют страницу.
			2. Скрипты с defer всегда выполняются, когда дерево DOM готово, но до события DOMContentLoaded.
		Отложенные с помощью defer скрипты сохраняют порядок относительно друг друга, как и обычные скрипты.

		Допустим, у нас есть два скрипта c defer: small.js и long.js:
			<script defer src="https://javascript.info/article/script-async-defer/long.js"></script>
			<script defer src="https://javascript.info/article/script-async-defer/small.js"></script>
		Браузеры сканируют страницу на предмет скриптов и загружают их параллельно в целях увеличения производительности.
		…Но defer не только говорит браузеру «не блокировать рендеринг», он также обеспечивает правильную последовательность выполнения скриптов.
		Даже если small.js загрузится первым, он будет ждать выполнения long.js.

		'ВАЖНО!'
			Атрибут defer будет проигнорирован, если в теге <script> нет src.
			Как и в случае с defer, атрибут async будет проигнорирован, если в теге <script> нет src.

	async:
		Атрибут async означает, что скрипт абсолютно независим:
			1. Страница не ждёт асинхронных скриптов, содержимое обрабатывается и отображается.
			2. Событие DOMContentLoaded и асинхронные скрипты не ждут друг друга:
				1. DOMContentLoaded может произойти как до асинхронного скрипта (если асинхронный скрипт завершит загрузку после того, как страница будет готова),
				2. …так и после асинхронного скрипта (если он короткий или уже содержится в HTTP-кеше)
			3. Остальные скрипты не ждут async, и скрипты casync не ждут другие скрипты.
		Так что если у нас есть несколько скриптов с async, они могут выполняться в любом порядке. То, что первое загрузится – запустится в первую очередь

		Асинхронные скрипты очень полезны для добавления на страницу сторонних скриптов: счётчиков, рекламы и т.д.
		Они не зависят от наших скриптов, и мы тоже не должны ждать их

	Динамически загружаемые скрипты
		Мы можем также добавить скрипт и динамически, с помощью JavaScript:
			let script = document.createElement('script');
			script.src = "/article/script-async-defer/long.js";
			document.body.append(script); // (*)
		Динамически загружаемые скрипты по умолчанию ведут себя как «async».

Загрузка ресурсов: onload и onerror:
	Браузер позволяет отслеживать загрузку сторонних ресурсов: скриптов, ифреймов, изображений и др.
	Для этого существуют два события:
		1. 'load' – успешная загрузка,
		2. 'error' – во время загрузки произошла ошибка.

	Загрузка скриптов:
		script.onload
			Главный помощник – это событие load. Оно срабатывает после того, как скрипт был загружен и выполнен.
				let script = document.createElement('script');
				// мы можем загрузить любой скрипт с любого домена
				script.src = "https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js"
				document.head.append(script);
				script.onload = function() {
					// в скрипте создаётся вспомогательная переменная с именем "_"
					alert(_.VERSION); // отображает версию библиотеки
				};
			Таким образом, в обработчике onload мы можем использовать переменные, вызывать функции и т.д., которые предоставляет нам сторонний скрипт.

		script.onerror
			Ошибки, которые возникают во время загрузки скрипта, могут быть отслежены с помощью события error.

			'ВАЖНО!'
				Обработчики onload/onerror отслеживают только сам процесс загрузки.
				Ошибки обработки и выполнения загруженного скрипта ими не отслеживаются. Чтобы «поймать» ошибки в скрипте,
				нужно воспользоваться глобальным обработчиком window.onerror.

	Ошибка в скрипте с другого источника
		Есть правило: скрипты с одного сайта не могут получить доступ к содержимому другого сайта.
		Например, скрипт с https://facebook.com не может прочитать почту пользователя на https://gmail.com.

		Это правило также касается ресурсов с других доменов.
		Если мы используем скрипт с другого домена, и в нем имеется ошибка, мы не сможем узнать детали этой ошибки.

		Зачем нам могут быть нужны детали ошибки?
		Существует много сервисов (и мы можем сделать наш собственный), которые обрабатывают глобальные ошибки при помощи window.onerror, сохраняют отчёт о них и предоставляют доступ к этому отчёту для анализа. Это здорово, потому что мы можем увидеть реальные ошибки, которые случились у наших пользователей. Но если скрипт – с другого домена, то информации об ошибках в нём почти нет, как мы только что видели.
		Похожая кросс-доменная политика (CORS) внедрена и в отношении других ресурсов.
		Чтобы разрешить кросс-доменный доступ, нам нужно поставить тегу <script> атрибут crossorigin, и, кроме того, удалённый сервер должен поставить специальные заголовки.
		Существует три уровня кросс-доменного доступа:
			1. Атрибут crossorigin отсутствует – доступ запрещён.
			2. crossorigin="anonymous" – доступ разрешён, если сервер отвечает с заголовком Access-Control-Allow-Origin со значениями * или наш домен. Браузер не отправляет авторизационную информацию и куки на удалённый сервер.
			3. crossorigin="use-credentials" – доступ разрешён, если сервер отвечает с заголовками Access-Control-Allow-Origin со значением наш домен и Access-Control-Allow-Credentials: true. Браузер отправляет авторизационную информацию и куки на удалённый сервер.

			Если куки нас не волнуют, тогда смело выбираем "anonymous"
			Теперь при условии, что сервер предоставил заголовок Access-Control-Allow-Origin, всё хорошо. У нас есть полный отчёт по ошибкам.

Разное:
	MutationObserver – это встроенный объект, наблюдающий за DOM-элементом и запускающий колбэк в случае изменений.
	Синтаксис:
		MutationObserver очень прост в использовании.
		Сначала мы создаём наблюдатель за изменениями с помощью колбэк-функции:
			'let observer = new MutationObserver(callback);'
		Потом прикрепляем его к DOM-узлу:
			'observer.observe(node, config);'
		config – это объект с булевыми параметрами «на какие изменения реагировать»:
			1. childList – изменения в непосредственных детях node,
			2. subtree – во всех потомках node,
			3. attributes – в атрибутах node,
			4. attributeFilter – массив имён атрибутов, чтобы наблюдать только за выбранными.
			5. characterData – наблюдать ли за node.data (текстовое содержимое),
		И ещё пара опций:
			'characterDataOldValue' – если true, будет передавать и старое, и новое значение node.data в колбэк (см далее), иначе только новое (также требуется опция characterData),
			'attributeOldValue' – если true, будет передавать и старое, и новое значение атрибута в колбэк (см далее), иначе только новое (также требуется опция attributes).

	Использование для интеграции:
		Когда это может быть нужно?
		Представим ситуацию, когда вы подключаете сторонний скрипт, который добавляет какую-то полезную функциональность на страницу,
			но при этом делает что-то лишнее, например, показывает рекламу <div class="ads">Ненужная реклама</div>.
		Разумеется, сторонний скрипт не даёт каких-то механизмов её убрать.
		Используя MutationObserver, мы можем отследить, когда в нашем DOM появится такой элемент и удалить его.

	Использование для архитектуры
		Есть и ситуации, когда MutationObserver хорошо подходит с архитектурной точки зрения.
		Представим, что мы создаём сайт о программировании. Естественно, статьи на нём и другие материалы могут содержать фрагменты с исходным кодом.
		Такой фрагмент в HTML-разметке выглядит так:
			<pre class="language-javascript"><code>
				// вот код
				let hello = "world";
			</code></pre>
		Также на нашем сайте мы будем использовать JavaScript-библиотеку для подсветки синтаксиса, например Prism.js.
		Когда конкретно нам вызвать этот метод подсветки?
		Мы можем использовать MutationObserver, чтобы автоматически определять момент, когда примеры кода появляются на странице, и подсвечивать их.

	Дополнительные методы
		Метод, останавливающий наблюдение за узлом:
			'observer.disconnect()' – останавливает наблюдение.
		Вместе с ним используют метод:
			'mutationRecords = observer.takeRecords()' - получает список необработанных записей изменений, которые произошли, но колбэк для них ещё не выполнился.

Selection и Range:
	В этой главе мы рассмотрим выделение как в документе, так и в полях формы, таких как <input>.

	Range
		В основе выделения лежит Range – диапазон. Он представляет собой пару «граничных точек»: начало и конец диапазона.
		Каждая точка представлена как родительский DOM-узел с относительным смещением от начала. Если этот узел – DOM-элемент,
			то смещение – это номер дочернего элемента, а для текстового узла смещение – позиция в тексте.

		Давайте что-нибудь выделим.
		Для начала мы создадим диапазон (конструктор не имеет параметров):
			'let range = new Range();'
		Затем мы установим границы выделения, используя 'range.setStart(node, offset)' и 'range.setEnd(node, offset)'.
		Например, рассмотрим этот фрагмент HTML-кода:
			<p id="p">Example: <i>italic</i> and <b>bold</b></p>
		Выделим "Example: <i>italic</i>". Это первые два дочерних узла тега <p> (учитывая текстовые узлы):
			<p id="p">Example: <i>italic</i> and <b>bold</b></p>
								|______|		|_____|		|___|		|___|
										0					1					2				3
		Скрипт:
			<script>
				let range = new Range();
				range.setStart(p, 0);
				range.setEnd(p, 2);
				// toString, вызванный у экземпляра Range, возвращает его содержимое в виде текста (без тегов)
				alert(range); // Example: italic
				// применим этот диапазон к выделению документа (объясняется далее)
				document.getSelection().addRange(range);
			</script>
		'range.setStart(p, 0)' – устанавливает начало диапазона на нулевом дочернем элементе тега <p> (Это текстовый узел "Example: ").
		'range.setEnd(p, 2)' – расширяет диапазон до 2го (но не включая его) дочернего элемента тега <p>

		Методы Range:
			https://learn.javascript.ru/selection-range#metody-range

	Selection:
		Range это общий объект для управления диапазонами выделения. Мы можем создавать и передавать подобные объекты.
		Сами по себе они ничего визуально не выделяют.

		Выделение в документе представлено объектом Selection, который может быть получен как 'window.getSelection()' или 'document.getSelection()'.

	Свойства Selection:
		https://learn.javascript.ru/selection-range#svoystva-selection

	События при выделении:
	Методы Selection:
	Выделение в элементах форм:
	Сделать что-то невыделяемым:
		https://learn.javascript.ru/selection-range#sobytiya-pri-vydelenii

Событийный цикл: микрозадачи и макрозадачи:
	Поток выполнения в браузере, равно как и в Node.js, основан на 'событийном цикле'.
	Понимание работы событийного цикла важно для оптимизаций, иногда для правильной архитектуры.
	Браузер отрисовывает содержимое страницы после того, как заканчивается выполнение текущего кода. Не имеет значения, насколько долго выполняется задача. Изменения в DOM отображаются только после её завершения.

	Событийный цикл
		Идея событийного цикла очень проста. Есть бесконечный цикл, в котором движок JavaScript ожидает задачи, исполняет их и снова ожидает появления новых.
		Общий алгоритм движка:
		Пока есть задачи:
			1. выполнить их, начиная с самой старой
			2. Бездействовать до появления новой задачи, а затем перейти к пункту 1
		Это формализация того, что мы наблюдаем, просматривая веб-страницу. Движок JavaScript большую часть времени ничего не делает и работает,
		только если требуется исполнить скрипт/обработчик или обработать событие.

		Может так случиться, что задача поступает, когда движок занят чем-то другим, тогда она ставится в очередь.
		Очередь, которую формируют такие задачи, называют 'очередью макрозадач' (macrotask queue, термин v8).

		Задачи из очереди исполняются по правилу «первым пришёл – первым ушёл».
		Отметим две детали:
			1. Рендеринг (отрисовка страницы) никогда не происходит во время выполнения задачи движком. Не имеет значения, сколь долго выполняется задача.
				Изменения в DOM отрисовываются только после того, как задача выполнена.
			2. Если задача выполняется очень долго, то браузер не может выполнять другие задачи, обрабатывать пользовательские события, поэтому спустя некоторое время браузер предлагает
				«убить» долго выполняющуюся задачу. Такое возможно, когда в скрипте много сложных вычислений или ошибка, ведущая к бесконечному циклу.

		Пример 1: разбиение «тяжёлой» задачи:
		Допустим, у нас есть задача, требующая значительных ресурсов процессора.
		Например, подсветка синтаксиса – довольно процессороёмкая задача.

		Пока движок занят подсветкой синтаксиса, он не может делать ничего, связанного с DOM, не может обрабатывать пользовательские события и т.д.

		Мы можем избежать этого, разбив задачу на части. Сделать подсветку для первых 100 строк, затем запланировать setTimeout (с нулевой задержкой)
		для разметки следующих 100 строк и т.д.

		Теперь если новая сторонняя задача (например, событие onclick) появляется, пока движок занят выполнением 1-й части, то она становится в очередь,
		и затем выполняется, когда 1-я часть завершена, перед следующей частью. Периодические возвраты в событийный цикл между запусками count дают движку
		достаточно «воздуха», чтобы сделать что-то ещё, отреагировать на действия пользователя.

	Макрозадачи и Микрозадачи:
		Микрозадачи приходят только из кода. Обычно они создаются промисами: выполнение обработчика .then/catch/finally становится 'микрозадачей'.
		Микрозадачи также используются «под капотом» await, т.к. это форма обработки промиса.
		Также есть специальная функция 'queueMicrotask(func)', которая помещает func в очередь микрозадач.

		Сразу после каждой макрозадачи движок исполняет все задачи из очереди микрозадач перед тем, как выполнить следующую макрозадачу или отобразить изменения на странице, или сделать что-то ещё.

		Например:
			setTimeout(() => alert("timeout"));
			Promise.resolve()
				.then(() => alert("promise"));
			alert("code");
		Какой здесь будет порядок?
			1. code появляется первым, т.к. это обычный синхронный вызов.
			2. promise появляется вторым, потому что .then проходит через очередь микрозадач и выполняется после текущего синхронного кода.
			3. timeout появляется последним, потому что это макрозадача.
		Все микрозадачи завершаются до обработки каких-либо событий или рендеринга, или перехода к другой макрозадаче.






Методы:
	<html> = document.documentElement
	<body> = document.body
	<head> = document.head

	Коллекция 'childNodes' содержит список всех детей, включая текстовые узлы
	Свойства 'firstChild' и 'lastChild' обеспечивают быстрый доступ к первому и последнему дочернему элементу
	Для проверки наличия дочерних узлов существует также специальная функция 'elem.hasChildNodes()'
	Следующий сосед того же родителя - 'nextSibling', предыдущий - 'previousSibling'
	Родитель доступен через 'parentNode'

	Навигационные свойства, описанные выше, относятся ко всем узлам в документе.
	В частности, в childNodes находятся и текстовые узлы и узлы-элементы и узлы-комментарии, если они есть.
	Поэтому давайте рассмотрим дополнительный набор ссылок, которые учитывают только узлы-элементы
	Эти ссылки похожи на те, что раньше, только в ряде мест стоит слово Element:
		'children' - коллекция детей, которые являются элементами.
		'firstElementChild', 'lastElementChild' - первый и последний дочерний элемент.
		'previousElementSibling', 'nextElementSibling' - соседи-элементы.
		'parentElement' - родитель-элемент.

	Элемент <table>, в дополнение к свойствам, о которых речь шла выше, поддерживает следующие:
		'table.rows' – коллекция строк <tr> таблицы.
		'table.caption/tHead/tFoot' – ссылки на элементы таблицы <caption>, <thead>, <tfoot>.
		'table.tBodies' – коллекция элементов таблицы <tbody> (по спецификации их может быть больше одного).
	<thead>, <tfoot>, <tbody> предоставляют свойство rows:
		'tbody.rows' – коллекция строк <tr> секции.
	<tr>:
		'tr.cells' – коллекция <td> и <th> ячеек, находящихся внутри строки <tr>.
		'tr.sectionRowIndex' – номер строки <tr> в текущей секции <thead>/<tbody>/<tfoot>.
		'tr.rowIndex' – номер строки <tr> в таблице (включая все строки таблицы).
	<td> and <th>:
		'td.cellIndex' – номер ячейки в строке <tr>.

	Если у элемента есть атрибут id, то мы можем получить его вызовом 'document.getElementById(id)', где бы он ни находился.
	Самый универсальный метод поиска – это 'elem.querySelectorAll(css)', он возвращает все элементы внутри elem, удовлетворяющие данному CSS-селектору.
	'elem.querySelector(css)' возвращает первый элемент, соответствующий данному CSS-селектору.

	Метод 'elem.matches(css)' ничего не ищет, а проверяет, удовлетворяет ли elem CSS-селектору, и возвращает true или false
	Метод 'elem.closest(css)' ищет ближайшего предка, который соответствует CSS-селектору. Сам элемент также включается в поиск

	'elem.getElementsByTagName(tag)' - ищет элементы с данным тегом и возвращает их коллекцию. Передав "*" вместо тега, можно получить всех потомков
	'elem.getElementsByClassName(className)' - возвращает элементы, которые имеют данный CSS-класс
	'document.getElementsByName(name)' - возвращает элементы с заданным атрибутом name. Очень редко используется

	Свойство 'nodeType' предоставляет ещё один, «старомодный» способ узнать «тип» DOM-узла
	Получив DOM-узел, мы можем узнать имя его тега из свойств 'nodeName' и 'tagName':
	Свойство 'innerHTML' позволяет получить HTML-содержимое элемента в виде строки
	Свойство 'outerHTML' содержит HTML элемента целиком. Это как innerHTML плюс сам элемент

	Свойство innerHTML есть только у узлов-элементов
	У других типов узлов, в частности, у текстовых, есть свои аналоги: свойства 'nodeValue' и 'data'
	Эти свойства очень похожи при использовании, есть лишь небольшие различия в спецификации.

	Свойство 'textContent' предоставляет доступ к тексту внутри элемента за вычетом всех <тегов>.
	С textContent вставка получается «как текст», все символы трактуются буквально. (<b><span> будут как текст, а не узел-элемент)

	Атрибут и DOM-свойство 'hidden' указывает на то, видим ли мы элемент или нет.
	Технически, hidden работает так же, как style="display:none". Но его применение проще.

	У DOM-элементов есть дополнительные свойства, в частности, зависящие от класса:
		'value' - значение для <input>, <select> и <textarea> (HTMLInputElement, HTMLSelectElement…).
		'href' - адрес ссылки «href» для <a href="..."> (HTMLAnchorElement).
		'id' - значение атрибута «id» для всех элементов (HTMLElement).
		…и многие другие…


	Для нестандартных атрибутов не будет соответствующих DOM-свойств. Есть ли способ получить такие атрибуты?
	Конечно. Все атрибуты доступны с помощью следующих методов:
		'elem.hasAttribute(name)' – проверяет наличие атрибута.
		'elem.getAttribute(name)' – получает значение атрибута.
		'elem.setAttribute(name, value)' – устанавливает значение атрибута.
		'elem.removeAttribute(name)' – удаляет атрибут.
	Кроме этого, получить все атрибуты элемента можно с помощью свойства 'elem.attributes'

	Все атрибуты, начинающиеся с префикса «data-», зарезервированы для использования программистами. Они доступны в свойстве 'dataset'.
	Например, если у elem есть атрибут "data-about", то обратиться к нему можно как elem.dataset.about.
	Атрибуты, состоящие из нескольких слов, к примеру data-order-state, становятся свойствами, записанными с помощью верблюжьей нотации: dataset.orderState.

	DOM-узел можно создать двумя методами:
		1. Создаёт новый элемент с заданным тегом:
			'document.createElement(tag)' -> let div = document.createElement('div');
		2. Создаёт новый текстовый узел с заданным текстом:
			'document.createTextNode(text)' -> let textNode = document.createTextNode('А вот и я');
	Чтобы наш div появился, нам нужно вставить его где-нибудь в document. Например, в document.body.
	Для этого есть метод append, в нашем случае: 'document.body.append(div)'.
	Вот методы для различных вариантов вставки:
		'node.append(...nodes or strings)' - добавляет узлы или строки в конец node,
		'node.prepend(...nodes or strings)' - вставляет узлы или строки в начало node,
		'node.before(...nodes or strings)' - вставляет узлы или строки до node,
		'node.after(...nodes or strings)' - вставляет узлы или строки после node,
		'node.replaceWith(...nodes or strings)' - заменяет node заданными узлами или строками.
	Пример:
		ol.before('before'); // вставить строку "before" перед <ol>
  	ol.after('after'); // вставить строку "after" после <ol>
	Эти методы могут вставлять несколько узлов и текстовых фрагментов за один вызов.
	Весь текст вставляется как текст. (<p> будет как текст, а не как тег)
		div.before('<p>Привет</p>', document.createElement('hr'));
	Эти методы могут использоваться только для вставки DOM-узлов или текстовых фрагментов.

	'elem.insertAdjacentHTML(where, html).'
	Первый параметр – это специальное слово, указывающее, куда по отношению к elem производить вставку. Значение должно быть одним из следующих:
		"beforebegin" – вставить html непосредственно перед elem,
		"afterbegin" – вставить html в начало elem,
		"beforeend" – вставить html в конец elem,
		"afterend" – вставить html непосредственно после elem.
	Второй параметр – это HTML-строка, которая будет вставлена именно «как HTML».
	Пример:
		div.insertAdjacentHTML('beforebegin', '<p>Привет</p>');
		div.insertAdjacentHTML('afterend', '<p>Пока</p>');
	У метода есть два брата:
		elem.insertAdjacentText(where, text) – такой же синтаксис, но строка text вставляется «как текст», вместо HTML,
		elem.insertAdjacentElement(where, elem) – такой же синтаксис, но вставляет элемент elem.
	Они существуют, в основном, чтобы унифицировать синтаксис. На практике часто используется только insertAdjacentHTML

	Для удаления узла есть методы 'node.remove()'.
	Если нам нужно переместить элемент в другое место – нет необходимости удалять его со старого.
	Все методы вставки автоматически удаляют узлы со старых мест.
		<div id="first">Первый</div>
		<div id="second">Второй</div>
		<script>
			// нет необходимости вызывать метод remove
			second.after(first); // берёт #second и после него вставляет #first
		</script>

	Вызов 'elem.cloneNode(true)' создаёт «глубокий» клон элемента – со всеми атрибутами и дочерними элементами.
	Если мы вызовем 'elem.cloneNode(false)', тогда клон будет без дочерних элементов.

	'elem.className' соответствует атрибуту "class".
		alert(document.body.className); // main page
	Если мы присваиваем что-то elem.className, то это заменяет всю строку с классами.
	Иногда это то, что нам нужно, но часто мы хотим добавить/удалить один класс.
	'elem.classList' – это специальный объект с методами для добавления/удаления одного класса.
		document.body.classList.add('article');
		document.body.classList.add('article');
	Методы classList:
		'elem.classList.add/remove("class")' – добавить/удалить класс.
		'elem.classList.toggle("class")' – добавить класс, если его нет, иначе удалить.
		'elem.classList.contains("class")' – проверка наличия класса, возвращает true/false.

	'elem.style' – это объект, который соответствует тому, что написано в атрибуте "style".
	Если мы установим в style.display пустую строку (Работает не только для display), то браузер применит CSS-классы и встроенные
	стили, как если бы такого свойства style.display вообще не было.

	Для задания нескольких стилей в одной строке используется специальное свойство 'style.cssText'
	Это свойство редко используется, потому что такое присваивание удаляет все существующие стили

	Свойство style оперирует только значением атрибута "style", без учёта CSS-каскада.
	Поэтому, используя elem.style, мы не можем прочитать ничего, что приходит из классов CSS.
	Но что, если нам нужно, скажем, увеличить отступ на 20px? Для начала нужно его текущее значение получить.
	Для этого есть метод: 'getComputedStyle'.
		let computedStyle = getComputedStyle(document.body);
		alert( computedStyle.marginTop ); // 5px
	Посещённые ссылки могут быть окрашены с помощью псевдокласса :visited.
	Но getComputedStyle не даёт доступ к этой информации, чтобы произвольная страница не могла определить, посещал ли пользователь ту или иную ссылку, проверив стили.

	'element.addEventListener(event, handler, [options]);'
		event - Имя события, например "click".
		handler - Ссылка на функцию-обработчик.
		options - Дополнительный объект со свойствами
			1. once: если true, тогда обработчик будет автоматически удалён после выполнения.
			2. capture: фаза, на которой должен сработать обработчик, подробнее об этом будет рассказано в главе Всплытие и погружение. Так исторически сложилось, что options может быть false/true, это то же самое, что {capture: false/true}.
			3. passive: если true, то указывает, что обработчик никогда не вызовет preventDefault(), подробнее об этом будет рассказано в главе Действия браузера по умолчанию.
				Для удаления обработчика следует использовать removeEventListener
	Метод addEventListener позволяет добавлять несколько обработчиков на одно событие одного элемента, например:
		elem.onclick = () => alert("Привет");
		elem.addEventListener("click", handler1); // Спасибо!
  	elem.addEventListener("click", handler2); // Спасибо ещё раз!


	'element.removeEventListener(event, handler, [options]);'
	Для удаления нужно передать именно ту функцию-обработчик которая была назначена.
	Вот так не сработает:
		elem.addEventListener( "click" , () => alert('Спасибо!'));
		// ....
		elem.removeEventListener( "click", () => alert('Спасибо!'));
	Вот так правильно:
		function handler() {
			alert( 'Спасибо!' );
		}
		input.addEventListener("click", handler);
		// ....
		input.removeEventListener("click", handler);
	Обратим внимание – если функцию обработчик не сохранить где-либо, мы не сможем её удалить.

	'event.stopPropagation()' - остановить всплытие
	Для того, чтобы полностью остановить обработку, существует метод 'event.stopImmediatePropagation()'.
	Он не только предотвращает всплытие, но и останавливает обработку событий на текущем элементе.

	Существует свойство 'event.eventPhase', содержащее номер фазы, на которой событие было поймано.

	Для отмены действия браузера существует стандартный метод 'event.preventDefault()'.