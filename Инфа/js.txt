Variables:
	Переменные с именами apple и APPLE – это две разные переменные.

	В старые времена было технически возможно создать переменную простым присвоением значения без использования let. Это все ещё работает, если мы не включаем use strict в наших файлах, чтобы обеспечить совместимость со старыми скриптами:
		// заметка: "use strict" в этом примере не используется
		num = 5; // если переменная "num" раньше не существовала, она создаётся
		alert(num); // 5
		
Types:
	Специальное значение null не относится ни к одному из типов, описанных выше.
	Специальное значение undefined также стоит особняком. Оно формирует тип из самого себя так же, как и null.
		
function:

	Другими словами:

	Параметр – это переменная, указанная в круглых скобках в объявлении функции.
	Аргумент – это значение, которое передаётся функции при её вызове.
	
	Если при вызове функции аргумент не был указан, то его значением становится undefined.
	

Function Expression:

	Function Declaration (Объявление Функции):
		function sayHi() {
  		alert( "Привет" );
		}
	
	Function Expression (Функциональное Выражение).
		let sayHi = function() {
			alert( "Привет" );
		};
		
	Arrow functions (Стрелочные функции)
		let func = (arg1, arg2, ...argN) => expression;
		
	Независимо от того, как создаётся функция – она является значением. В обоих приведённых выше примерах функция хранится в переменной sayHi.
	
	Мы можем скопировать функцию в другую переменную:
		function sayHi() {
			alert( "Привет" );
		}
		let func = sayHi;
		func();
		sayHi();
		
	Function Expression в сравнении с Function Declaration:
		Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться.
		Function Declaration может быть вызвана раньше, чем она объявлена.
		В строгом режиме, когда Function Declaration находится в блоке {...}, функция доступна везде внутри блока. Но не снаружи него.


Объекты:
	Для удаления свойства мы можем использовать оператор delete:
		delete user.age;
	Имя свойства может состоять из нескольких слов, но тогда оно должно быть заключено в кавычки:
		let user = {
			name: "John",
			age: 30,
			"likes birds": true
		};
		user["likes birds"] = true;
	Свойство из переменной:
		function makeUser(name, age) {
			return {
				name, // то же самое, что и name: name
				age   // то же самое, что и age: age
				// ...
			};
		}
	Нет никаких ограничений к именам свойств. 
	let obj = {
		0: "Тест", // то же самое что и "0": "Тест"
		return: 3
	};
	Cуществует специальный оператор "in" для проверки существования свойства в объекте:
		// "key" in object
		let user = { name: "John", age: 30 };
		alert( "age" in user ); // true, user.age существует
	Для перебора всех свойств объекта используется цикл for..in:
		for (key in object) {
			// тело цикла выполняется для каждого свойства объекта
		}
	Cвойства упорядочены особым образом: свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания.
	Термин «целочисленное свойство» означает строку, которая может быть преобразована в целое число и обратно без изменений.
				
	Два объекта равны только в том случае, если это один и тот же объект.
		let a = {};
		let b = a; // копирование по ссылке
		alert( a == b ); // true, обе переменные ссылаются на один и тот же объект
		alert( a === b ); // true
				
	Object.assign - копирование объекта
	structuredClone() - позволяет сделать полную копию объекта (со вложенными объектами) (поддерживается только современными браузерами.)
			
Object: Basic
	Существует более короткий синтаксис для методов в литерале объекта:
		// эти объекты делают одно и то же
		user = {
			sayHi: function() {
				alert("Привет");
			}
		};
		// сокращённая запись выглядит лучше, не так ли?
		user = {
			sayHi() { // то же самое, что и "sayHi: function(){...}"
				alert("Привет");
			}
		};
		
	Для доступа к информации внутри объекта метод может использовать ключевое слово this.
		let user = {
			name: "John",
			age: 30,

			sayHi() {
				// "this" - это "текущий объект".
				alert(this.name);
			}
		};

	this:	
		Вызов без объекта: this == undefined
		В JavaScript this является «свободным», его значение вычисляется в момент вызова метода и не зависит от того, где этот метод был объявлен
			let user = { name: "John" };
			function sayHi() {
				alert(this);
			}
			user.f = sayHi;
		У стрелочных функций нет «this». Если мы ссылаемся на this внутри такой функции, то оно берётся из внешней «нормальной» функции.
					
			
Конструктор, оператор "new"
	Функции-конструкторы технически являются обычными функциями. Но есть два соглашения:
	1. Имя функции-конструктора должно начинаться с большой буквы.
	2. Функция-конструктор должна выполняться только с помощью оператора "new".

		function User(name) {
			// this = {};  (неявно)
  		this.name = name;
			this.isAdmin = false;
			// return this;  (неявно)
		}

		let user = new User("Jack");

		alert(user.name); // Jack
		alert(user.isAdmin); // false
		
	Технически любая функция (кроме стрелочных функций, поскольку у них нет this) может использоваться в качестве конструктора. Его можно запустить с помощью new, и он выполнит выше указанный алгоритм.
		
	если return всё же есть, то применяется простое правило:
		При вызове return с объектом, вместо this вернётся объект.
		При вызове return с примитивным значением, оно проигнорируется.
				
	Кстати, мы можем не ставить круглые скобки после new:
		let user = new User; // <-- без скобок
		// то же, что и
		let user = new User();
	Пропуск скобок считается плохой практикой
	
Опциональная цепочка
	Опциональная цепочка ?. останавливает вычисление и возвращает undefined, если значение перед ?. равно undefined или null.
	Так например, в записи user?.address.street.name ?. позволяет user безопасно быть null/undefined (и в этом случае возвращает undefined), но это так только для user.
	
	Переменная перед ?. должна быть объявлена
		// ReferenceError: user is not defined
		user?.address;
	Переменная должна быть объявлена (к примеру, как let)
	
	?. — это не оператор, а специальная синтаксическая конструкция, которая также работает с функциями и квадратными скобками.
	Например, ?.() используется для вызова функции, которая может не существовать.
		let userAdmin = {
			admin() {
				alert("Я админ");
			}
		};
		userAdmin.admin?.();
	Синтаксис ?.[] также работает, если мы хотим использовать скобки [] для доступа к свойствам вместо точки .
		let user1 = {
			firstName: "John"
		};
		alert( user1?.[key] );
	
	Также мы можем использовать ?. с delete:
		delete user?.name; // удаляет user.name если пользователь существует
	
	Мы можем использовать ?. для безопасного чтения и удаления, но не для записи
		let user = null;
		user?.name = "John"; // Ошибка, не работает
		
Тип данных Symbol
	По спецификации, в качестве ключей для свойств объекта могут использоваться только строки или символы.
	
	«Символ» представляет собой уникальный идентификатор.
	Создаются новые символы с помощью функции Symbol(),
	При создании, символу можно дать описание (также называемое имя), в основном использующееся для отладки кода:
		// Создаём символ id с описанием (именем) "id"
		let id = Symbol("id");
		
	Символы гарантированно уникальны.
		let id1 = Symbol("id");
		let id2 = Symbol("id");

		alert(id1 == id2); // false
		
	Символы не преобразуются автоматически в строки!

Преобразование объектов в примитивы
	Что произойдёт, если сложить два объекта obj1 + obj2, вычесть один из другого obj1 - obj2 или вывести их на экран, воспользовавшись alert(obj)?
	В случае таких операций, объекты автоматически преобразуются в примитивы
	Это важное ограничение: результатом obj1 + obj2 (или другой математической операции) не может быть другой объект!
	
	Правила преобразования объектов:
		1. В логическом контексте все объекты являются true, всё просто.
		2. Преобразований к строке – оно обычно происходит, когда мы выводим на экран объект при помощи alert(obj) и в подобных контекстах.
		3. Числовое преобразование - ???
		
Методы примитивов
	Каждый примитив имеет свой собственный «объект-обёртку», которые называются: String, Number, Boolean, Symbol и BigInt (с использованием оператора new).
	
	Конструкторы String/Number/Boolean предназначены только для внутреннего пользования
	Использование функций String/Number/Boolean без оператора new – вполне разумно и полезно. Они превращают значение в соответствующий примитивный тип
	
	null/undefined не имеют методов
	
Числа
	В JavaScript можно использовать букву "e", чтобы укоротить запись числа.
		let billion = 1e9;  // 1 миллиард, буквально: 1 и 9 нулей
		let ms = 1e-6; // шесть нулей, слева от 1
		
	Шестнадцатеричные, двоичные и восьмеричные числа:
		let a = 0b11111111; // бинарная форма записи числа 255
		let b = 0o377; // восьмеричная форма записи числа 255
		alert( 0xff ); // шестнадцатиричная форма записи числа 255 
		
	num.toString(base) возвращает строковое представление числа num в системе счисления base:
		alert( 123456..toString(36) ); // 2n9c
		
	Другим забавным следствием внутреннего представления чисел является наличие двух нулей: 0 и -0.
	Все потому, что знак представлен отдельным битом
	
Строки
	Спецсимволы
		\n	Перевод строки
		\', \"	Кавычки
		\t	Знак табуляции
		
	Свойство length содержит длину строки:
		alert( `My\n`.length ); // 3
		
	Доступ к символам
		let str = `Hello`;
		// получаем последний символ
		alert( str[str.length - 1] ); // o
		alert( str.at(-1) ); // o
		
Массив
	Внутреннее устройство массива:
		Массив – это особый подвид объектов.
		Движок JavaScript старается хранить элементы массива в непрерывной области памяти, один за другим благодаря этому массивы работают очень быстро
		Но все они утратят эффективность, если мы перестанем работать с массивом как с «упорядоченной коллекцией данных» и начнём использовать его как обычный объект.
		
	for..of - перебор массива
	for..in - перебор объекта (не стоит использовать с массивом, т.к работает с ним в 10-100 раз медленней) 
	
	length – его можно перезаписать.
	Если мы вручную увеличим его, ничего интересного не произойдёт. Зато, если мы уменьшим его, массив станет короче. 
	
	new Array():
		let arr = new Array(2); // создастся ли массив [2]?
		alert( arr[0] ); // undefined! нет элементов.
		alert( arr.length ); // length 2
		
	toString
		Массивы по-своему реализуют метод toString
			let arr = [1, 2, 3];
			alert( String(arr) === '1,2,3' ); // true
			alert( [1,2] + 1 ); // "1,21"
	
	Не сравнивайте массивы при помощи ==
		Давайте ещё раз напомним правила:
			1. Два объекта равны друг другу == только в том случае, если они ссылаются на один и тот же объект.
			2. Если один из аргументов == является объектом, а другой – примитивом, то объект преобразуется в примитив
		Оператор строгого равенства === ещё проще, так как он не преобразует типы.
		
Методы массивов
	Большинство методов поддерживают «thisArg»
		Почти все методы массива, которые вызывают функции – такие как find, filter, map, за исключением метода sort, принимают необязательный параметр thisArg.
			let army = {
				minAge: 18,
				maxAge: 27,
				canJoin(user) {
					return user.age >= this.minAge && user.age < this.maxAge;
				}
			};

			let users = [
				{age: 16},
				{age: 20},
				{age: 23},
				{age: 30}
			];

			// найти пользователей, для которых army.canJoin возвращает true
			let soldiers = users.filter(army.canJoin, army);
		Если бы мы в примере выше использовали просто users.filter(army.canJoin), то вызов army.canJoin был бы в режиме отдельной функции, с this=undefined. Это тут же привело бы к ошибке.
		Вызов users.filter(army.canJoin, army) можно заменить на users.filter(user => army.canJoin(user))

Перебираемые объекты
	Перебираемые (или итерируемые) объекты – это обобщение массивов. Концепция, которая позволяет использовать любой объект в цикле for..of.
	Symbol.iterator:
			let range = {
				from: 1,
				to: 5
			};
		Чтобы сделать range итерируемым (и позволить for..of работать с ним), нам нужно добавить в объект метод с именем Symbol.iterator
			1. Когда цикл for..of запускается, он вызывает этот метод один раз (или выдаёт ошибку, если метод не найден). Этот метод должен вернуть итератор – объект с методом next.
			2. Дальше for..of работает только с этим возвращённым объектом.
			3. Когда for..of хочет получить следующее значение, он вызывает метод next() этого объекта.
			4. Результат вызова next() должен иметь вид {done: Boolean, value: any}, где done=true означает, что цикл завершён, в противном случае value содержит очередное значение.
		Вот полная реализация range с пояснениями:
			let range = {
				from: 1,
				to: 5,

				[Symbol.iterator]() {
					this.current = this.from;
					return this;
				},

				next() {
					if (this.current <= this.to) {
						return { done: false, value: this.current++ };
					} else {
						return { done: true };
					}
				}
			};

			for (let num of range) {
				alert(num); // 1, затем 2, 3, 4, 5
			}
		
	Строка – перебираемый объект
		for (let char of "test") {
			// срабатывает 4 раза: по одному для каждого символа
			alert( char ); // t, затем e, затем s, затем t
		}
	
	Итерируемые объекты и псевдомассивы
		Итерируемые объекты – это объекты, которые реализуют метод Symbol.iterator (для них работает for..of), как было описано выше.
		Псевдомассивы – это объекты, у которых есть индексы и свойство length, то есть, они выглядят как массивы.
		Например, строки итерируемы (для них работает for..of) и являются псевдомассивами (они индексированы и есть length).
		
Map и Set
	Map
		Map – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа.
		Использование объектов в качестве ключей – одна из наиболее заметных и важных функций Map. Это то что невозможно для Object.
		В отличие от обычных объектов Object, в Map перебор происходит в том же порядке, в каком происходило добавление элементов.
		
	Set
		Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.
		Основная «изюминка» – это то, что при повторных вызовах set.add() с одним и тем же значением ничего не происходит

WeakMap и WeakSet
	Как мы знаем из главы Сборка мусора, движок JavaScript хранит значения в памяти до тех пор, пока они достижимы
	Но если мы используем объект как ключ в Map, то до тех пор, пока существует Map, также будет существовать и этот объект. 
		let john = { name: "John" };

		let map = new Map();
		map.set(john, "...");

		john = null; // перезаписываем ссылку на объект

		// объект john сохранён внутри объекта `Map`,
		// он доступен через map.keys()
		
	WeakMap
		Первое его отличие от Map в том, что ключи в WeakMap должны быть объектами, а не примитивными значениями:
			let weakMap = new WeakMap();
			let obj = {};
			weakMap.set(obj, "ok"); // работает (объект в качестве ключа)
		Теперь, если мы используем объект в качестве ключа и если больше нет ссылок на этот объект, то он будет удалён из памяти (и из объекта WeakMap) автоматически.
		
	WeakSet
		Коллекция WeakSet ведёт себя похоже:
			* Она аналогична Set, но мы можем добавлять в WeakSet только объекты (не примитивные значения).
			* Объект присутствует в множестве только до тех пор, пока доступен где-то ещё.
			* Как и Set, она поддерживает add, has и delete, но не size, keys() и не является перебираемой.
	
	Наиболее значительным ограничением WeakMap и WeakSet является то, что их нельзя перебрать или взять всё содержимое. 

Object.keys, values, entries
	Трансформации объекта
		У объектов нет множества методов, которые есть в массивах, например map, filter и других.
		Если мы хотели бы их применить, то можно использовать Object.entries с последующим вызовом Object.fromEntries:
			1. Вызов Object.entries(obj) возвращает массив пар ключ/значение для obj.
			2. На нём вызываем методы массива, например, map.
			3. Используем Object.fromEntries(array) на результате, чтобы преобразовать его обратно в объект.
				let prices = {
					banana: 1,
					orange: 2,
					meat: 4,
				};

				let doublePrices = Object.fromEntries(
					// преобразовать в массив, затем map, затем fromEntries обратно объект
					Object.entries(prices).map(([key, value]) => [key, value * 2])
				);

				alert(doublePrices.meat); // 8
				
Деструктурирующее присваивание
	Деструктурирующее присваивание – это специальный синтаксис, который позволяет нам «распаковать» массивы или объекты в несколько переменных, так как иногда они более удобны.
		let arr = ["Ilya", "Kantor"];
		let [firstName, surname] = arr;
		alert(firstName); // Ilya
		alert(surname);  // Kantor
	
	«Деструктурирующее присваивание» не уничтожает массив. Оно вообще ничего не делает с правой частью присваивания
	
	Нежелательные элементы массива также могут быть отброшены с помощью дополнительной запятой:
		let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];
		alert( title ); // Consul

	Работает с любым перебираемым объектом с правой стороны
		let [a, b, c] = "abc";
		let [one, two, three] = new Set([1, 2, 3]);
	
	Присваивайте чему угодно с левой стороны
		let user = {};
		[user.name, user.surname] = "Ilya Kantor".split(' ');

	Цикл с .entries()
		let user = {
			name: "John",
			age: 30
		};

		// цикл по ключам и значениям
		for (let [key, value] of Object.entries(user)) {
			alert(`${key}:${value}`); // name:John, затем age:30
		}
		
	Трюк обмена переменных
		let guest = "Jane";
		let admin = "Pete";

		[guest, admin] = [admin, guest];
		
	Остаточные параметры «…»
		let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];
		alert(rest[1]); // of the Roman Republic
		alert(rest.length); // 2
		
	Значения по умолчанию
		Если в массиве меньше значений, чем в присваивании, то ошибки не будет. Отсутствующие значения считаются неопределёнными:
			let [firstName, surname] = [];
			alert(firstName); // undefined
			alert(surname); // undefined
		Если мы хотим, чтобы значение «по умолчанию» заменило отсутствующее, мы можем указать его с помощью =:
			let [name = "Guest", surname = "Anonymous"] = ["Julius"];
			
	Деструктуризация объекта
			let {var1, var2} = {var1:…, var2:…}
		Если мы хотим присвоить свойство объекта переменной с другим названием, например, свойство options.width присвоить переменной w, то мы можем использовать двоеточие:
			let options = {
				title: "Menu",
				width: 100,
				height: 200
			};
			
			let {width: w, height: h, title} = options;
			
			alert(w);      // 100
			alert(h);      // 200
		
		Мы также можем совмещать : и =:
			let options = {
				title: "Menu"
			};

			let {width: w = 100, height: h = 200, title} = options;

			alert(title);  // Menu
			alert(w);      // 100
			alert(h);      // 200
			
		Остаток объекта «…»
			let options = {
				title: "Menu",
				height: 200,
				width: 100
			};

			let {title, ...rest} = options;

			alert(rest.height);  // 200
			
		Вот так не будет работать:
			let title, width, height;
			{title, width, height} = {title: "Menu", width: 200, height: 100};
		Так будет работать:
			({title, width, height} = {title: "Menu", width: 200, height: 100});
			
		Вложенная деструктуризация
			Она есть, но зачем?)
		
		Умные параметры функций
			Мы можем передать параметры как объект, и функция немедленно деструктурирует его в переменные:
				let options = {
					title: "My menu",
					items: ["Item1", "Item2"]
				};
				// ...и она немедленно извлекает свойства в переменные
				function showMenu({title = "Untitled", width = 200, height = 100, items = []}) {
					// title, items – взято из options,
					// width, height – используются значения по умолчанию
					alert( `${title} ${width} ${height}` ); // My Menu 200 100
					alert( items ); // Item1, Item2
				}
				showMenu(options);
				
Рекурсия и стек
	Максимальная глубина рекурсии ограничена движком JavaScript. Точно можно рассчитывать на 10000 вложенных вызовов, некоторые интерпретаторы допускают и больше, но для большинства из них 100000 вызовов – за пределами возможностей.

Остаточные параметры и оператор расширения
	Остаточные параметры (...)
		Вызывать функцию можно с любым количеством аргументов независимо от того, как она была определена.
			function sum(a, b) {
				return a + b;
			}

			alert( sum(1, 2, 3, 4, 5) );
		Лишние аргументы не вызовут ошибку.
		
		соберём все аргументы в массив args:
			function sumAll(...args) { // args — имя массива
				let sum = 0;

				for (let arg of args) sum += arg;

				return sum;
			}

			alert( sumAll(1, 2, 3) ); // 6
		
		Переменная "arguments"
			Все аргументы функции находятся в псевдомассиве arguments под своими порядковыми номерами.
				function showName() {
					alert( arguments.length );
					alert( arguments[0] );
					alert( arguments[1] );
				}
				showName("Юлий", "Цезарь");
			Хотя arguments похож на массив, и его тоже можно перебирать, это всё же не массив. Он не поддерживает методы массивов, поэтому мы не можем, например, вызвать arguments.map(...).
			Стрелочные функции не имеют "arguments"!
			
		Оператор расширения
				let arr2 = [8, 3, -8, 1];
				alert( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25
				
			Оператор расширения можно использовать и для слияния массивов:
				let arr = [3, 5, 1];
				let arr2 = [8, 9, 15];

				let merged = [0, ...arr, 2, ...arr2];
				
			Оператор расширения работает с любым перебираемым объектом.
				let str = "Привет";
				alert( [...str] ); // П,р,и,в,е,т
				
Замыкание
	Лексическое Окружение
		В JavaScript у каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний (скрытый) объект, называемый лексическим окружением LexicalEnvironment.
		Объект лексического окружения состоит из двух частей:
			1. Environment Record – объект, в котором как свойства хранятся все локальные переменные (а также некоторая другая информация, такая как значение this).
			2. Ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок).
		"Переменная" – это просто свойство специального внутреннего объекта: Environment Record. «Получить или изменить переменную», означает, «получить или изменить свойство этого объекта».
		У глобального лексического окружения (окружение вне функции, блока кода и скрипта) нет внешнего окружения, так что она указывает на null.
	
	Function Declaration
		Function Declaration в отличие от переменных, объявленных с помощью let, они полностью инициализируются не тогда, когда выполнение доходит до них, а раньше, когда создаётся лексическое окружение.
	
	Внутреннее и внешнее лексическое окружение
		Когда код хочет получить доступ к переменной – сначала происходит поиск во внутреннем лексическом окружении, затем во внешнем, затем в следующем и так далее, до глобального.
		Функция получает текущее значение внешних переменных, то есть их последнее значение. Старые значения переменных нигде не сохраняются.
		Новое лексическое окружение функции создаётся каждый раз, когда функция выполняется. И, если функция вызывается несколько раз, то для каждого вызова будет своё лексическое окружение, со своими, специфичными для этого вызова, локальными переменными и параметрами.
		«Лексическое окружение» – это специальный внутренний объект. Мы не можем получить его в нашем коде и изменять напрямую.

	Вложенные функции
		Функция называется «вложенной», когда она создаётся внутри другой функции.
			function makeCounter() {
				let count = 0;
				return function() {
					return count++;
				};
			}

			let counter1 = makeCounter();
			let counter2 = makeCounter();

			alert( counter1() ); // 0
			alert( counter1() ); // 1

			alert( counter2() ); // 0 (независимо)
	
	Окружение в деталях
		Все функции «при рождении» получают скрытое свойство [[Environment]], которое ссылается на лексическое окружение места, где они были созданы.
		Функция навсегда запоминает ссылку на лексическое окружение, где она была создана. И [[Environment]] – скрытое свойство функции, которое содержит эту ссылку.
	
		Не имеет значения, какой способ объявления функции используется: Function Declaration или Function Expression. Все функции получают свойство [[Environment]], которое ссылается на лексическое окружение, в котором они были созданы.
		
		При вызове counter1() для этого вызова создаётся новое лексическое окружение. Оно пустое, так как в самом counter локальных переменных нет. Но [[Environment]] counter используется, как ссылка на внешнее лексическое окружение outer
		
		Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. В JavaScript, все функции изначально являются замыканиями (за исключением new Function). То есть они автоматически запоминают, где были созданы, с помощью скрытого свойства [[Environment]], и все они могут получить доступ к внешним переменным.
	
	Блоки кода и циклы, IIFE
		Предыдущие примеры сосредоточены на функциях. Но лексическое окружение существует для любых блоков кода {...}.
		
		For, while
			Но конструкция for – особенная в этом смысле, у каждой итерации цикла своё собственное лексическое окружение с текущим i в нём.
		
		Блоки кода
			Мы также можем использовать «простые» блоки кода {...}, чтобы изолировать переменные в «локальной области видимости».
				{
					// сделать какую-нибудь работу с локальными переменными, которые не должны быть видны снаружи

					let message = "Hello";

					alert(message); // Hello
				}

				alert(message); // Ошибка: переменная message не определена
				
		IIFE
			Это не то, что мы должны использовать сегодня, но, так как вы можете встретить это в старых скриптах, полезно понимать принцип работы.
				(function() {

					let message = "Hello";

					alert(message); // Hello

				})();
				
		Сборка мусора
			Обычно лексическое окружение очищается и удаляется после того, как функция выполнилась.
			
		Оптимизация на практике
			Одним из важных побочных эффектов в V8 (Chrome, Opera) является то, что такая переменная становится недоступной при отладке.
				function f() {
					let value = Math.random();

					function g() {
						debugger; // в консоли: напишите alert(value); Такой переменной нет!
					}

					return g;
				}

				let g = f();
				g();
			Как вы можете видеть – такой переменной не существует! В теории, она должна быть доступна, но попала под оптимизацию движка.

Устаревшее ключевое слово "var"
	let и const ведут себя одинаково по отношению к лексическому окружению, области видимости.
	
	Особенности var:
		1. Для «var» не существует блочной области видимости
			if (true) {
				var test = true; // используем var вместо let
			}

			alert(test); // true, переменная существует вне блока if
			
		2. «var» допускает повторное объявление
			let user;
			let user; // SyntaxError: 'user' has already been declared
			
			var user = "Pete";
			var user; // ничего не делает, переменная объявлена раньше
			// ...нет ошибки

			alert(user); // Pete
			
		3. «var» обрабатываются в начале запуска функции
		
Глобальный объект
	Глобальный объект предоставляет переменные и функции, доступные в любом месте программы. По умолчанию это те, что встроены в язык или среду исполнения.
	
	Ко всем свойствам глобального объекта можно обращаться напрямую:
		alert("Привет");
		// это то же самое, что и
		window.alert("Привет");
	
	В браузере глобальные функции и переменные, объявленные с помощью var (не let/const!), становятся свойствами глобального объекта:
		var gVar = 5;
		alert(window.gVar); // 5 (становится свойством глобального объекта)
		
	То же самое касается функций, объявленных с помощью синтаксиса Function Declaration
		
	Пожалуйста, не полагайтесь на это. Такое поведение поддерживается для совместимости. В современных проектах, использующих JavaScript-модули, такого не происходит.
	
	Если свойство настолько важное, что вы хотите сделать его доступным для всей программы, запишите его в глобальный объект напрямую:
		// сделать информацию о текущем пользователе глобальной, для предоставления доступа всем скриптам
		window.currentUser = {
			name: "John"
		};

		// где угодно в коде
		alert(currentUser.name); // John
	При этом обычно не рекомендуется использовать глобальные переменные. Следует применять их как можно реже.
	
	Использование для полифилов
		Глобальный объект можно использовать, чтобы проверить поддержку современных возможностей языка.
		if (!window.Promise) {
			alert("Ваш браузер очень старый!");
			// OR
			window.Promise = ...
		}
		
Объект функции, NFE
	В JavaScript функции – это объекты.
	Функции можно не только вызывать, но и использовать их как обычные объекты: добавлять/удалять свойства, передавать их по ссылке и т.д.
	
	Свойство «name»
		function sayHi() {
			alert("Hi");
		}

		alert(sayHi.name); // sayHi
		
	Свойство «length»
		function f1(a) {}
		function f2(a, b) {}
		function many(a, b, ...more) {}

		alert(f1.length); // 1
		alert(f2.length); // 2
		alert(many.length); // 2
		
	Пользовательские свойства
		Мы также можем добавить свои собственные свойства.
			function sayHi() {
				alert("Hi");

				// давайте посчитаем, сколько вызовов мы сделали
				sayHi.counter++;
			}
			sayHi.counter = 0; // начальное значение

			sayHi(); // Hi
			sayHi(); // Hi

			alert( `Вызвана ${sayHi.counter} раза` ); // Вызвана 2 раза
		
	Named Function Expression
		Есть две важные особенности имени func, ради которого оно даётся:
			1. Оно позволяет функции ссылаться на себя же.
			2. Оно не доступно за пределами функции.
			
				let sayHi = function func(who) {
					if (who) {
						alert(`Hello, ${who}`);
					} else {
						func("Guest"); // использует func, чтобы снова вызвать себя же
					}
				};

				sayHi(); // Hello, Guest

				// А вот так - не cработает:
				func(); // Ошибка, func не определена (недоступна вне функции)
		
		Почему мы используем func? Почему просто не использовать sayHi для вложенного вызова? Вообще, обычно мы можем так поступить
		Однако, у этого кода есть проблема, которая заключается в том, что значение sayHi может быть изменено. Функция может быть присвоена другой переменной, и тогда код начнёт выдавать ошибки

Синтаксис "new Function"
		let func = new Function([arg1, arg2, ...argN], functionBody);
	
	Это проще понять на конкретном примере. Здесь объявлена функция с двумя аргументами:
		let sum = new Function('a', 'b', 'return a + b');
		alert( sum(1, 2) ); // 3
		
		let sayHi = new Function('alert("Hello")');
		sayHi(); // Hello
	Главное отличие от других способов объявления функции, которые были рассмотрены ранее, заключается в том, что функция создаётся полностью «на лету» из строки, переданной во время выполнения.
	
	Замыкание
		Но когда функция создаётся с использованием new Function, в её [[Environment]] записывается ссылка не на внешнее лексическое окружение, в котором она была создана, а на глобальное.
			function getFunc() {
				let value = "test";
				let func = new Function('alert(value)');
				return func;
			}
			
			getFunc()(); // ошибка: value не определено
			
		Проблема в том, что перед отправкой JavaScript-кода на реальные работающие проекты код сжимается с помощью минификатора – специальной программы, которая уменьшает размер кода, удаляя комментарии, лишние пробелы, и, что самое главное, локальным переменным даются укороченные имена.
		Например, если в функции объявляется переменная let userName, то минификатор изменяет её на let a
		
Планирование: setTimeout и setInterval
	setTimeout
		Например, данный код вызывает sayHi() спустя одну секунду:
			function sayHi(phrase, who) {
				alert( phrase + ', ' + who );
			}
			setTimeout(sayHi, 1000, "Привет", "Джон"); // Привет, Джон
		
		Если первый аргумент является строкой, то JavaScript создаст из неё функцию.
			setTimeout("alert('Привет')", 1000);
		Но использование строк не рекомендуется. Вместо этого используйте функции. Например, так:
			setTimeout(() => alert('Привет'), 1000);
			
	Отмена через clearTimeout
		Вызов setTimeout возвращает «идентификатор таймера» timerId, который можно использовать для отмены дальнейшего выполнения.	
			let timerId = setTimeout(...);
			clearTimeout(timerId);
			
	setInterval
			// повторить с интервалом 2 секунды
			let timerId = setInterval(() => alert('tick'), 2000);

			// остановить вывод через 5 секунд
			setTimeout(() => { clearInterval(timerId); alert('stop'); }, 5000);
		
		Во время показа alert время тоже идёт
		
		Есть два способа запускать что-то регулярно.
		Один из них setInterval. Другим является вложенный setTimeout. Например:
			let timerId = setTimeout(function tick() {
				alert('tick');
				timerId = setTimeout(tick, 2000); // (*)
			}, 2000);
		Вложенный setTimeout позволяет задать задержку между выполнениями более точно, чем setInterval.
		Сравним два фрагмента кода. Первый использует setInterval:
			let i = 1;
			setInterval(function() {
				func(i);
			}, 100);
		Второй использует вложенный setTimeout:
			let i = 1;
			setTimeout(function run() {
				func(i);
				setTimeout(run, 100);
			}, 100);
		Реальная задержка между вызовами func с помощью setInterval меньше, чем указано в коде!
		В крайнем случае, если функция всегда выполняется дольше, чем задержка delay, то вызовы будут выполняться без задержек вообще.
		Вложенный setTimeout гарантирует фиксированную задержку (здесь 100 мс).
    Это потому, что новый вызов планируется в конце предыдущего.
    
    setTimeout с нулевой задержкой
    	Особый вариант использования: setTimeout(func, 0) или просто setTimeout(func).
			Это планирует вызов func настолько быстро, насколько это возможно. Но планировщик будет вызывать функцию только после завершения выполнения текущего кода.
			
			В браузере есть ограничение на то, как часто внутренние счётчики могут выполняться. В стандарте HTML5 говорится: «после пяти вложенных таймеров интервал должен составлять не менее четырёх миллисекунд.».
			
Декораторы и переадресация вызова, call/apply
	Декоратор – это обёртка вокруг функции, которая изменяет поведение последней. Основная работа по-прежнему выполняется функцией.


	Прозрачное кеширование
			function slow(x) {
				// здесь могут быть ресурсоёмкие вычисления
				alert(`Called with ${x}`);
				return x;
			}

			function cachingDecorator(func) {
				let cache = new Map();
				return function(x) {
					if (cache.has(x)) {    // если кеш содержит такой x,
						return cache.get(x); // читаем из него результат
					}
					let result = func(x); // иначе, вызываем функцию
					cache.set(x, result); // и кешируем (запоминаем) результат
					return result;
				};
			}

			slow = cachingDecorator(slow);
			
			alert( slow(1) ); // slow(1) кешируем
			alert( "Again: " + slow(1) ); // возвращаем из кеша
			alert( slow(2) ); // slow(2) кешируем
		В коде выше cachingDecorator – это декоратор, специальная функция, которая принимает другую функцию и изменяет её поведение.
		Идея состоит в том, что мы можем вызвать cachingDecorator с любой функцией, в результате чего мы получим кеширующую обёртку.
	
	Применение «func.call» для передачи контекста.
		Упомянутый выше кеширующий декоратор не подходит для работы с методами объектов.
			// сделаем worker.slow кеширующим
			let worker = {
				someMethod() {
					return 1;
				},
				slow(x) {
					// здесь может быть страшно тяжёлая задача для процессора
					alert("Called with " + x);
					return x * this.someMethod(); // (*)
				}
			};
			// тот же код, что и выше
			function cachingDecorator(func) {
				let cache = new Map();
				return function(x) {
					if (cache.has(x)) {
						return cache.get(x);
					}
					let result = func(x); // (**)
					cache.set(x, result);
					return result;
				};
			}
			alert( worker.slow(1) ); // оригинальный метод работает
			worker.slow = cachingDecorator(worker.slow); // теперь сделаем его кеширующим
			alert( worker.slow(2) ); // Ой! Ошибка: не удаётся прочитать свойство 'someMethod' из 'undefined'
		Причина в том, что в строке (**) декоратор вызывает оригинальную функцию как func(x), и она в данном случае получает this = undefined.
		Т.е. декоратор передаёт вызов оригинальному методу, но без контекста.
		Существует специальный встроенный метод функции func.call(context, …args), который позволяет вызывать функцию, явно устанавливая this.
			func.call(context, arg1, arg2, ...)
		Например, в приведённом ниже коде мы вызываем sayHi в контексте различных объектов:
			function sayHi() {
				alert(this.name);
			}
			let user = { name: "John" };
			let admin = { name: "Admin" };
			// используем 'call' для передачи различных объектов в качестве 'this'
			sayHi.call( user ); // John
			sayHi.call( admin ); // Admin
		Чтобы было все правильно в предыдущем примере нужно строчку (**) заменить на:
			let result = func.call(this, x);
	
	Переходим к нескольким аргументам с «func.apply»
		https://learn.javascript.ru/call-apply-decorators#perehodim-k-neskolkim-argumentam-s-func-apply
		
Привязка контекста к функции
	https://learn.javascript.ru/bind
	
Повторяем стрелочные функции
	У стрелочных функций нет «this»
	Стрелочные функции нельзя использовать с new
	Стрелочные функции не имеют «arguments»

Флаги и дескрипторы свойств
	Флаги свойств
		Помимо значения value, свойства объекта имеют три специальных атрибута (так называемые «флаги»).
			writable – если true, свойство можно изменить, иначе оно только для чтения.
			enumerable – если true, свойство перечисляется в циклах, в противном случае циклы его игнорируют.
			configurable – если true, свойство можно удалить, а эти атрибуты можно изменять, иначе этого делать нельзя.
		Когда мы создаём свойство «обычным способом», все они имеют значение true.
		Метод Object.getOwnPropertyDescriptor позволяет получить полную информацию о свойстве.
			let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);
		
		Чтобы изменить флаги, мы можем использовать метод Object.defineProperty.
			Object.defineProperty(obj, propertyName, descriptor)
		Если свойство существует, defineProperty обновит его флаги. В противном случае метод создаёт новое свойство с указанным значением и флагами; если какой-либо флаг не указан явно, ему присваивается значение false.
		
	Неконфигурируемое свойство
		Неконфигурируемое свойство (configurable:false) не может быть удалено, его атрибуты не могут быть изменены.
		Определение свойства как неконфигурируемого – это дорога в один конец. Мы не можем изменить его обратно с помощью defineProperty.
		Обратите внимание: configurable: false не даст изменить флаги свойства, а также не даст его удалить. При этом можно изменить значение свойства.
	
	Метод Object.defineProperties
		Существует метод Object.defineProperties(obj, descriptors), который позволяет определять множество свойств сразу.
			Object.defineProperties(obj, {
				prop1: descriptor1,
				prop2: descriptor2
				// ...
			});
			
Свойства - геттеры и сеттеры
	Есть два типа свойств объекта.
		Первый тип это свойства-данные (data properties).
		Второй тип свойств это свойства-аксессоры (accessor properties).
	
	Геттеры и сеттеры
		Свойства-аксессоры представлены методами: «геттер» – для чтения и «сеттер» – для записи.
		При литеральном объявлении объекта они обозначаются get и set:
			let obj = {
				get propName() {
					// геттер, срабатывает при чтении obj.propName
				},

				set propName(value) {
					// сеттер, срабатывает при записи obj.propName = value
				}
			};
		Пример использования:
			let user = {
				name: "John",
				surname: "Smith",

				get fullName() {
					return `${this.name} ${this.surname}`;
				}
			};

			alert(user.fullName); // John Smith
			user.fullName = "Тест"; // Ошибка (у свойства есть только геттер)
		Исправим:
			let user = {
				name: "John",
				surname: "Smith",

				get fullName() {
					return `${this.name} ${this.surname}`;
				},

				set fullName(value) {
					[this.name, this.surname] = value.split(" ");
				}
			};

			// set fullName запустится с данным значением
			user.fullName = "Alice Cooper";

			alert(user.name); // Alice
			alert(user.surname); // Cooper
			
	Дескрипторы свойств доступа
		Свойства-аксессоры не имеют value и writable
		
	Умные геттеры/сеттеры
		Если мы хотим запретить устанавливать короткое имя для user, мы можем использовать сеттер name для проверки, а само значение хранить в отдельном свойстве _name:
			let user = {
				get name() {
					return this._name;
				},

				set name(value) {
					if (value.length < 4) {
						alert("Имя слишком короткое, должно быть более 4 символов");
						return;
					}
					this._name = value;
				}
			};

			user.name = "Pete";
			alert(user.name); // Pete

			user.name = ""; // Имя слишком короткое...
		Технически, внешний код всё ещё может получить доступ к имени напрямую с помощью user._name, но существует широко известное соглашение о том, что свойства, которые начинаются с символа "_", являются внутренними, и к ним не следует обращаться из-за пределов объекта.
	
	
Прототипное наследование
	Прототипное наследование — это возможность языка, которая помогает в этом. (Мы хотели бы повторно использовать то, что есть у объекта user, не копировать/переопределять его методы, а просто создать новый объект на его основе.)

	[[Prototype]]
		В JavaScript объекты имеют специальное скрытое свойство [[Prototype]], которое либо равно null, либо ссылается на другой объект. Этот объект называется «прототип»:
		Прототип даёт нам немного «магии». Когда мы хотим прочитать свойство из object, а оно отсутствует, JavaScript автоматически берёт его из прототипа.
		
		Свойство [[Prototype]] является внутренним и скрытым, но есть много способов задать его.
		Одним из них является использование __proto__, например так:
			let animal = {
				eats: true
			};
			let rabbit = {
				jumps: true
			};

			rabbit.__proto__ = animal;
		Если мы ищем свойство в rabbit, а оно отсутствует, JavaScript автоматически берёт его из animal.
			alert( rabbit.eats ); // true (**)
			alert( rabbit.jumps ); // true
			
		Цепочка прототипов может быть длиннее:
			let animal = {
				eats: true,
				walk() {
					alert("Animal walk");
				}
			};

			let rabbit = {
				jumps: true,
				__proto__: animal
			};

			let longEar = {
				earLength: 10,
				__proto__: rabbit
			};

			// walk взят из цепочки прототипов
			longEar.walk(); // Animal walk
			alert(longEar.jumps); // true (из rabbit)
		Есть только два ограничения:
			1. Ссылки не могут идти по кругу. JavaScript выдаст ошибку, если мы попытаемся назначить __proto__ по кругу.
			2. Значение __proto__ может быть объектом или null. Другие типы игнорируются.
		Это вполне очевидно, но всё же: может быть только один [[Prototype]]. Объект не может наследоваться от двух других объектов.
	
	Операция записи не использует прототип
		Прототип используется только для чтения свойств.
		
	Значение «this»	
		Ответ прост: прототипы никак не влияют на this.
		Неважно, где находится метод: в объекте или его прототипе. При вызове метода this — всегда объект перед точкой. (admin.fullName= в качестве this использует admin, а не user(прототип admin))
		
	Цикл for…in
		Цикл for..in проходит не только по собственным, но и по унаследованным свойствам объекта.
		
F.prototype
	Как мы помним, новые объекты могут быть созданы с помощью функции-конструктора new F().
	Если в F.prototype содержится объект, оператор new устанавливает его в качестве [[Prototype]] для нового объекта.

	Обратите внимание, что F.prototype означает обычное свойство с именем "prototype" для F. Это ещё не «прототип объекта», а обычное свойство F с таким именем.
		let animal = {
			eats: true
		};

		function Rabbit(name) {
			this.name = name;
		}

		Rabbit.prototype = animal;

		let rabbit = new Rabbit("White Rabbit"); //  rabbit.__proto__ == animal

		alert( rabbit.eats ); // true
	Установка Rabbit.prototype = animal буквально говорит интерпретатору следующее: "При создании объекта через new Rabbit() запиши ему animal в [[Prototype]]".
	F.prototype используется только в момент вызова new F()
	
	F.prototype по умолчанию, свойство constructor
		У каждой функции по умолчанию уже есть свойство "prototype".
		По умолчанию "prototype" – объект с единственным свойством constructor, которое ссылается на функцию-конструктор.
		Вот такой:
			function Rabbit() {}

			/* прототип по умолчанию
			Rabbit.prototype = { constructor: Rabbit };
			*/
			alert( Rabbit.prototype.constructor == Rabbit ); // true
			
Встроенные прототипы
	Object.prototype
			let obj = {};
			alert( obj ); // "[object Object]" ?
		Где код, который генерирует строку "[object Object]"?
		obj = {} – это то же самое, что и obj = new Object(), где Object – встроенная функция-конструктор для объектов с собственным свойством prototype, которое ссылается на огромный объект с методом toString и другими.
			let obj = {};
			alert(obj.__proto__ === Object.prototype); // true
			
	Примитивы
		Самое сложное происходит со строками, числами и булевыми значениями.
		 Но если мы попытаемся получить доступ к их свойствам, то тогда будет создан временный объект-обёртка с использованием встроенных конструкторов String, Number и Boolean, который предоставит методы и после этого исчезнет.
		Значения null и undefined не имеют объектов-обёрток
		
	Изменение встроенных прототипов
		Встроенные прототипы можно изменять. Например, если добавить метод к String.prototype, метод становится доступен для всех строк:
			String.prototype.show = function() {
				alert(this);
			};
			"BOOM!".show(); // BOOM!
		Это плохая идея - добавлять методы во встроенные прототипы 
		Прототипы глобальны, поэтому очень легко могут возникнуть конфликты. Если две библиотеки добавляют метод String.prototype.show, то одна из них перепишет метод другой.
		В современном программировании есть только один случай, в котором одобряется изменение встроенных прототипов. Это создание полифилов.
	
	Заимствование у прототипов
			let obj = {
				0: "Hello",
				1: "world!",
				length: 2,
			};
			obj.join = Array.prototype.join;
			alert( obj.join(',') ); // Hello,world!
		Это работает, потому что для внутреннего алгоритма встроенного метода join важны только корректность индексов и свойство length, он не проверяет, является ли объект на самом деле массивом. И многие встроенные методы работают так же.	
		
Методы прототипов, объекты без свойства __proto__		
	Свойство __proto__ считается устаревшим, и по стандарту оно должно поддерживаться только браузерами.
	Современные же методы это:
		Object.create(proto, [descriptors]) – создаёт пустой объект со свойством [[Prototype]], указанным как proto
		Object.getPrototypeOf(obj) – возвращает свойство [[Prototype]] объекта obj.
		Object.setPrototypeOf(obj, proto) – устанавливает свойство [[Prototype]] объекта obj как proto.
			
			let animal = {
				eats: true
			};
			// создаём новый объект с прототипом animal
			let rabbit = Object.create(animal, {
				jumps: {
					value: true
				}
			});
			alert(rabbit.eats); // true
			alert(Object.getPrototypeOf(rabbit) === animal); // получаем прототип объекта rabbit
			Object.setPrototypeOf(rabbit, {}); // заменяем прототип объекта rabbit на {}
	
	Почему же __proto__ был заменён на функции getPrototypeOf/setPrototypeOf? Читайте далее, чтобы узнать ответ.
	Не меняйте [[Prototype]] существующих объектов, если важна скорость
	Технически мы можем установить/получить [[Prototype]] в любое время. Но обычно мы устанавливаем прототип только раз во время создания объекта, а после не меняем: rabbit наследует от animal, и это не изменится.
	И JavaScript движки хорошо оптимизированы для этого. Изменение прототипа «на лету» с помощью Object.setPrototypeOf или obj.__proto__= – очень медленная операция, которая ломает внутренние оптимизации для операций доступа к свойствам объекта.
	
	"Простейший" объект
			let obj = {};
			let key = prompt("What's the key?", "__proto__");
			obj[key] = "some value";
			alert(obj[key]); // [object Object], не "some value"!
		И это не должно удивлять нас. Свойство __proto__ особенное: оно должно быть либо объектом, либо null, а строка не может стать прототипом.

Обработка ошибок, "try..catch"
		try {
			// код...
		} catch (err) {
			// обработка ошибки
		}
	Переменная err (можно использовать любое имя) содержит объект ошибки с подробной информацией о произошедшем.
	
	try..catch работает только для ошибок, возникающих во время выполнения кода
	Он не сработает, если код синтаксически неверен, например, содержит несовпадающее количество фигурных скобок:
		try {
			{{{{{{{{{{{{
		} catch(e) {
			alert("Движок не может понять этот код, он некорректен");
		}
	JavaScript-движок сначала читает код, а затем исполняет его. Ошибки, которые возникают во время фазы чтения, называются ошибками парсинга. Их нельзя обработать
	
	try..catch работает синхронно
		Исключение, которое произойдёт в коде, запланированном «на будущее», например в setTimeout, try..catch не поймает:
			try {
				setTimeout(function() {
					noSuchVariable; // скрипт упадёт тут
				}, 1000);
			} catch (e) {
				alert( "не сработает" );
			}
		Чтобы поймать исключение внутри запланированной функции, try..catch должен находиться внутри самой этой функции:
			setTimeout(function() {
				try {
					noSuchVariable; // try..catch обрабатывает ошибку!
				} catch {
					alert( "ошибка поймана!" );
				}
			}, 1000);
			
	Объект ошибки
		Когда возникает ошибка, JavaScript генерирует объект, содержащий её детали. Затем этот объект передаётся как аргумент в блок catch:
		Для всех встроенных ошибок этот объект имеет два основных свойства:
		name - Имя ошибки. Например, для неопределённой переменной это "ReferenceError".
		message - Текстовое сообщение о деталях ошибки.
		stack - Текущий стек вызова: строка, содержащая информацию о последовательности вложенных вызовов, которые привели к ошибке.
		
	Блок «catch» без переменной
		Если нам не нужны детали ошибки, в catch можно её пропустить:
			try {
				// ...
			} catch { //  <-- без (err)
				// ...
			}
			
	Генерация собственных ошибок
		Оператор throw генерирует ошибку.
		Синтаксис:
			throw <объект ошибки>
		Технически в качестве объекта ошибки можно передать что угодно. Это может быть даже примитив, число или строка, но всё же лучше, чтобы это был объект
		В JavaScript есть множество встроенных конструкторов для стандартных ошибок: Error, SyntaxError, ReferenceError, TypeError и другие. Можно использовать и их для создания объектов ошибки.
		Их синтаксис:
			let error = new Error(message);
			let error = new SyntaxError(message);
			let error = new ReferenceError(message);
			
			alert(error.name); // Error
			alert(error.message); //  Ого, ошибка! o_O
			
		Сгенерируем её:
			let json = '{ "age": 30 }'; // данные неполны

			try {
				let user = JSON.parse(json); // <-- выполнится без ошибок
				if (!user.name) {
					throw new SyntaxError("Данные неполны: нет имени"); // (*)
				}
				alert( user.name );
			} catch(e) {
				alert( "JSON Error: " + e.message ); // JSON Error: Данные неполны: нет имени
			}
			
		try…catch…finally
			Конструкция try..catch может содержать ещё одну секцию: finally.
			Если секция есть, то она выполняется в любом случае:
				после try, если не было ошибок,
				после catch, если ошибки были.
					try {
						 ... пробуем выполнить код...
					} catch(e) {
						 ... обрабатываем ошибки ...
					} finally {
						 ... выполняем всегда ...
					}
			Переменные внутри try..catch..finally локальны
			Блок finally срабатывает при любом выходе из try..catch, в том числе и return.
			Конструкция try..finally без секции catch также полезна. Мы применяем её, когда не хотим здесь обрабатывать ошибки (пусть выпадут), но хотим быть уверены, что начатые процессы завершились.
		
		Глобальный catch
			Давайте представим, что произошла фатальная ошибка (программная или что-то ещё ужасное) снаружи try..catch, и скрипт упал.
			Такого способа нет в спецификации, но обычно окружения предоставляют его, потому что это весьма полезно.
			
Пользовательские ошибки, расширение Error
	https://learn.javascript.ru/custom-errors
	
Введение: колбэки
	https://learn.javascript.ru/callbacks
	
Промисы
	Это аналогия из реальной жизни для ситуаций, с которыми мы часто сталкиваемся в программировании:
	1. Есть «создающий» код, который делает что-то, что занимает время. Например, загружает данные по сети. В нашей аналогии это – «певец».
	2. Есть «потребляющий» код, который хочет получить результат «создающего» кода, когда он будет готов. Он может быть необходим более чем одной функции. Это – «фанаты».
	3. Promise (по англ. promise, будем называть такой объект «промис») – это специальный объект в JavaScript, который связывает «создающий» и «потребляющий» коды вместе. В терминах нашей аналогии – это «список для подписки». «Создающий» код может выполняться сколько потребуется, чтобы получить результат, а промис делает результат доступным для кода, который подписан на него, когда результат готов.
		
	Синтаксис создания Promise:
		let promise = new Promise(function(resolve, reject) {
			// функция-исполнитель (executor)
			// "певец"
		});
		
	Функция, переданная в конструкцию new Promise, называется исполнитель (executor). Когда Promise создаётся, она запускается автоматически. Она должна содержать «создающий» код, который когда-нибудь создаст результат. В терминах нашей аналогии: исполнитель – это «певец».	
	Когда он получает результат, сейчас или позже – не важно, он должен вызвать один из этих колбэков:
		resolve(value) — если работа завершилась успешно, с результатом value.
		reject(error) — если произошла ошибка, error – объект ошибки.
	Итак, исполнитель запускается автоматически, он должен выполнить работу, а затем вызвать resolve или reject.
	У объекта promise, возвращаемого конструктором new Promise, есть внутренние свойства:
		state («состояние») — вначале "pending" («ожидание»), потом меняется на "fulfilled" («выполнено успешно») при вызове resolve или на "rejected" («выполнено с ошибкой») при вызове reject.
		result («результат») — вначале undefined, далее изменяется на value при вызове resolve(value) или на error при вызове reject(error).
			
		let promise = new Promise(function(resolve, reject) {
			// эта функция выполнится автоматически, при вызове new Promise

			// через 1 секунду сигнализировать, что задача выполнена с результатом "done"
			setTimeout(() => resolve("done"), 1000);
		});
	Мы можем наблюдать две вещи, запустив код выше:
		Функция-исполнитель запускается сразу же при вызове new Promise.
		Исполнитель получает два аргумента: resolve и reject — это функции, встроенные в JavaScript, поэтому нам не нужно их писать.
	
	Исполнитель должен вызвать что-то одно: resolve или reject. Состояние промиса может быть изменено только один раз.
	Все последующие вызовы resolve и reject будут проигнорированы
	
	Вызывайте reject с объектом Error
	
	Обычно исполнитель делает что-то асинхронное и после этого вызывает resolve/reject, то есть через какое-то время. Но это не обязательно
	
	Потребители: then, catch
		Объект Promise служит связующим звеном между исполнителем и функциями-потребителями, которые получат либо результат, либо ошибку. Функции-потребители могут быть зарегистрированы (подписаны) с помощью методов .then и .catch.
		
		then
			Наиболее важный и фундаментальный метод – .then.
				promise.then(
					function(result) { /* обработает успешное выполнение */ },
					function(error) { /* обработает ошибку */ }
				);
			
			Если мы заинтересованы только в результате успешного выполнения задачи, то в then можно передать только одну функцию
			Если мы хотели бы только обработать ошибку, то можно использовать null в качестве первого аргумента: .then, или можно воспользоваться методом .catch(errorHandlingFunction)
			
		Очистка: finally
			По аналогии с блоком finally из обычного try {...} catch {...}, у промисов также есть метод finally.
			Идея finally состоит в том, чтобы настроить обработчик для выполнения очистки/доведения после завершения предыдущих операций.
			Код может выглядеть следующим образом:
				new Promise((resolve, reject) => {
					/* сделать что-то, что займёт время, и после вызвать resolve или может reject */
				})
					// выполнится, когда промис завершится, независимо от того, успешно или нет
					.finally(() => остановить индикатор загрузки)
					// таким образом, индикатор загрузки всегда останавливается, прежде чем мы продолжим
					.then(result => показать результат, err => показать ошибку)
			Есть важные различия:
				1. Обработчик, вызываемый из finally, не имеет аргументов.
				2. Обработчик finally «пропускает» результат или ошибку дальше, к последующим обработчикам.
				3. Обработчик finally также не должен ничего возвращать. Если это так, то возвращаемое значение молча игнорируется.

Цепочка промисов
	У нас есть последовательность асинхронных задач, которые должны быть выполнены одна за другой.
	Она выглядит вот так:
		new Promise(function(resolve, reject) {

			setTimeout(() => resolve(1), 1000); // (*)

		}).then(function(result) { // (**)

			alert(result); // 1
			return result * 2;

		}).then(function(result) { // (***)

			alert(result); // 2
			return result * 2;

		}).then(function(result) {

			alert(result); // 4
			return result * 2;

		});
	Идея состоит в том, что результат первого промиса передаётся по цепочке обработчиков .then.
	Всё это работает, потому что вызов promise.then тоже возвращает промис, так что мы можем вызвать на нём следующий .then.
	
	Классическая ошибка новичков: технически возможно добавить много обработчиков .then к единственному промису. Но это не цепочка.
	Например:
		let promise = new Promise(function(resolve, reject) {
			setTimeout(() => resolve(1), 1000);
		});

		promise.then(function(result) {
			alert(result); // 1
			return result * 2;
		});

		promise.then(function(result) {
			alert(result); // 1
			return result * 2;
		});

		promise.then(function(result) {
			alert(result); // 1
			return result * 2;
		});
	Мы добавили несколько обработчиков к одному промису. Они не передают друг другу результаты своего выполнения, а действуют независимо.
	
	Возвращаем промисы
		Обработчик handler, переданный в .then(handler), может вернуть промис.
		В этом случае дальнейшие обработчики ожидают, пока он выполнится, и затем получают его результат.
		Например:
			new Promise(function(resolve, reject) {
				setTimeout(() => resolve(1), 1000);
			}).then(function(result) {
				alert(result); // 1
				return new Promise((resolve, reject) => { // (*)
					setTimeout(() => resolve(result * 2), 1000);
				});
			}).then(function(result) { // (**)
				alert(result); // 2
				return new Promise((resolve, reject) => {
					setTimeout(() => resolve(result * 2), 1000);
				});
			}).then(function(result) {
				alert(result); // 4
			});
		
		Если быть более точными, обработчик может возвращать не именно промис, а любой объект, содержащий метод .then, такие объекты называют «thenable», и этот объект будет обработан как промис.
			class Thenable {
				constructor(num) {
					this.num = num;
				}
				then(resolve, reject) {
					alert(resolve); // function() { native code }
					// будет успешно выполнено с аргументом this.num*2 через 1 секунду
					setTimeout(() => resolve(this.num * 2), 1000); // (**)
				}
			}

			new Promise(resolve => resolve(1))
				.then(result => {
					return new Thenable(result); // (*)
				})
				.then(alert); // показывает 2 через 1000мс
				
Промисы: обработка ошибок
	Может быть, с сервером всё в порядке, но в ответе мы получим некорректный JSON. Самый лёгкий путь перехватить все ошибки – это добавить .catch в конец цепочки:
		fetch('/article/promise-chaining/user.json')
			.then(response => response.json())
			.then(user => fetch(`https://api.github.com/users/${user.name}`))
			.catch(error => alert(error.message));
	
	Неявный try…catch
		Вокруг функции промиса и обработчиков находится "невидимый try..catch". Если происходит исключение, то оно перехватывается, и промис считается отклонённым с этой ошибкой.
		Например, этот код:
			new Promise((resolve, reject) => {
				throw new Error("Ошибка!");
			}).catch(alert); // Error: Ошибка!
		…Работает так же, как и этот:
			new Promise((resolve, reject) => {
				reject(new Error("Ошибка!"));
			}).catch(alert); // Error: Ошибка!
	
	Пробрасывание ошибок
		Как мы уже заметили, .catch ведёт себя как try..catch. Мы можем иметь столько обработчиков .then, сколько мы хотим, и затем использовать один .catch в конце, чтобы перехватить ошибки из всех обработчиков.
		В обычном try..catch мы можем проанализировать ошибку и повторно пробросить дальше, если не можем её обработать. То же самое возможно для промисов.
			// the execution: catch -> then
			new Promise((resolve, reject) => {

				throw new Error("Ошибка!");

			}).catch(function(error) {

				alert("Ошибка обработана, продолжить работу");

			}).then(() => alert("Управление перейдёт в следующий then"));
	
	Необработанные ошибки
		Что произойдёт, если ошибка не будет обработана? Например, мы просто забыли добавить .catch в конец цепочки
		Что происходит, когда обычная ошибка не перехвачена try..catch? Скрипт умирает с сообщением в консоли. Похожее происходит и в случае необработанной ошибки промиса.
		
Promise API
	В классе Promise есть 6 статических методов. Давайте познакомимся с ними.
	
	Promise.all
		Допустим, нам нужно запустить множество промисов параллельно и дождаться, пока все они выполнятся.
		Для этого как раз и пригодится Promise.all.
		Синтаксис:
			let promise = Promise.all(iterable);
		Новый промис завершится, когда завершится весь переданный список промисов, и его результатом будет массив их результатов.
		Например, Promise.all, представленный ниже, выполнится спустя 3 секунды, его результатом будет массив [1, 2, 3]:
			Promise.all([
				new Promise(resolve => setTimeout(() => resolve(1), 3000)), // 1
				new Promise(resolve => setTimeout(() => resolve(2), 2000)), // 2
				new Promise(resolve => setTimeout(() => resolve(3), 1000))  // 3
			]).then(alert); // когда все промисы выполнятся, результат будет 1,2,3
			// каждый промис даёт элемент массива
		Обратите внимание, что порядок элементов массива в точности соответствует порядку исходных промисов. Даже если первый промис будет выполняться дольше всех, его результат всё равно будет первым в массиве.
		Если любой из промисов завершится с ошибкой, то промис, возвращённый Promise.all, немедленно завершается с этой ошибкой.
		В случае ошибки, остальные результаты игнорируются
		Если один промис завершается с ошибкой, то весь Promise.all завершается с ней, полностью забывая про остальные промисы в списке. Их результаты игнорируются.
		
	Promise.allSettled
			let promise = Promise.allSettled(iterable);
		Promise.all завершается с ошибкой, если она возникает в любом из переданных промисов.
		Метод Promise.allSettled всегда ждёт завершения всех промисов. В массиве результатов будет
			{status:"fulfilled", value:результат} для успешных завершений,
			{status:"rejected", reason:ошибка} для ошибок.
			
	Promise.race
		Метод очень похож на Promise.all, но ждёт только первый выполненный промис, из которого берёт результат (или ошибку).
		Например, тут результат будет 1:
			Promise.race([
				new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
				new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ошибка!")), 2000)),
				new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
			]).then(alert); // 1
			
	Promise.any
		Метод очень похож на Promise.race, но ждёт только первый успешно выполненный промис, из которого берёт результат.
	
	Promise.resolve/reject
		Методы Promise.resolve и Promise.reject редко используются в современном коде, так как синтаксис async/await (мы рассмотрим его чуть позже) делает их, в общем-то, не нужными.
		
		Promise.resolve
			Promise.resolve(value) создаёт успешно выполненный промис с результатом value.
			То же самое, что:
				let promise = new Promise(resolve => resolve(value));
				
		Promise.reject
			Promise.reject(error) создаёт промис, завершённый с ошибкой error.
			То же самое, что:
				let promise = new Promise((resolve, reject) => reject(error));

Промисификация
	Промисификация – это длинное слово для простого преобразования. Мы берём функцию, которая принимает колбэк и меняем её, чтобы она вместо этого возвращала промис.
	Например, у нас есть loadScript(src, callback).
		function loadScript(src, callback) {
			let script = document.createElement('script');
			script.src = src;

			script.onload = () => callback(null, script);
			script.onerror = () => callback(new Error(`Ошибка загрузки скрипта ${src}`));

			document.head.append(script);
		}
	Давайте промисифицируем её. 
		let loadScriptPromise = function(src) {
			return new Promise((resolve, reject) => {
				loadScript(src, (err, script) => {
				  if (err) reject(err)
				  else resolve(script);
				});
			})
		}

		// использование:
		// loadScriptPromise('path/script.js').then(...)
		
Микрозадачи
	Обработчики промисов .then/.catch/.finally всегда асинхронны.
	Вот демо:
		let promise = Promise.resolve();
		promise.then(() => alert("промис выполнен"));
		alert("код выполнен"); // этот alert показывается первым
		
	Если вы запустите его, сначала вы увидите код выполнен, а потом промис выполнен.
	Почему .then срабатывает позже? Что происходит?
	
	Очередь микрозадач
		Асинхронные задачи требуют правильного управления. Для этого стандарт предусматривает внутреннюю очередь PromiseJobs, более известную как «очередь микрозадач (microtask queue)» 
		Как сказано в спецификации:
			Очередь определяется как первым-пришёл-первым-ушёл (FIFO): задачи, попавшие в очередь первыми, выполняются тоже первыми.
			Выполнение задачи происходит только в том случае, если ничего больше не запущено.
	
	Необработанные ошибки
		"Необработанная ошибка" возникает в случае, если ошибка промиса не обрабатывается в конце очереди микрозадач.
		
Async/await
	Асинхронные функции
		Начнём с ключевого слова async. Оно ставится перед функцией, вот так:
			async function f() {
				return 1;
			}
		У слова async один простой смысл: эта функция всегда возвращает промис.
		Например, эта функция возвратит выполненный промис с результатом 1:
			async function f() {
				return 1;
			}

			f().then(alert); // 1
	
	Await
		Синтаксис:
			// работает только внутри async–функций
			let value = await promise;
		Ключевое слово await заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от await не выполнится. После чего оно вернёт его результат, и выполнение кода продолжится.
		В этом примере промис успешно выполнится через 1 секунду:
			async function f() {
				let promise = new Promise((resolve, reject) => {
					setTimeout(() => resolve("готово!"), 1000)
				});
				let result = await promise; // будет ждать, пока промис не выполнится (*)
				alert(result); // "готово!"
			}
			f();
		Обратите внимание, хотя await и заставляет JavaScript дожидаться выполнения промиса, это не отнимает ресурсов процессора. Пока промис не выполнится, JS-движок может заниматься другими задачами: выполнять прочие скрипты, обрабатывать события и т.п.
		
		await нельзя использовать в обычных функциях!
		
		await нельзя использовать на верхнем уровне вложенности! (вне тела функции). Но из-за того, что await работает только внутри async–функций, так сделать не получится
		
		await работает с «thenable»–объектами
		
		Асинхронные методы классов
		Для объявления асинхронного метода достаточно написать async перед именем:
			class Waiter {
				async wait() {
					return await Promise.resolve(1);
				}
			}
	Обработка ошибок
		Когда промис завершается успешно, await promise возвращает результат. Когда завершается с ошибкой – будет выброшено исключение. Как если бы на этом месте находилось выражение throw.
		Такой код:
			async function f() {
				await Promise.reject(new Error("Упс!"));
			}
		Делает то же самое, что и такой:
			async function f() {
				throw new Error("Упс!");
			}
		Такие ошибки можно ловить, используя try..catch, как с обычным throw:
			async function f() {
				try {
					let response = await fetch('http://no-such-url');
				} catch(err) {
					alert(err); // TypeError: failed to fetch
				}
			}
			f();
		
		async/await отлично работает с Promise.all
		Когда необходимо подождать несколько промисов одновременно, можно обернуть их в Promise.all, и затем await:
			// await будет ждать массив с результатами выполнения всех промисов
			let results = await Promise.all([
				fetch(url1),
				fetch(url2),
				...
			]);
			В случае ошибки она будет передаваться как обычно

Генераторы
	https://learn.javascript.ru/generators-iterators

Модули, введение
	Что такое модуль?
		Модуль – это просто файл. Один скрипт – это один модуль.
		Модули могут загружать друг друга и использовать директивы export и import, чтобы обмениваться функциональностью, вызывать функции одного модуля из другого:
			export отмечает переменные и функции, которые должны быть доступны вне текущего модуля.
			import позволяет импортировать функциональность из других модулей.
		
		Например, если у нас есть файл sayHi.js, который экспортирует функцию:
			// 📁 sayHi.js
			export function sayHi(user) {
				alert(`Hello, ${user}!`);
			}
		…Тогда другой файл может импортировать её и использовать:
			// 📁 main.js
			import {sayHi} from './sayHi.js';
			alert(sayHi); // function...
			sayHi('John'); // Hello, John!
			
		Модули не работают локально. Только через HTTP(s)
		Если вы попытаетесь открыть веб-страницу локально, через протокол file://, вы обнаружите, что директивы import/export не работают. 
		
	Основные возможности модулей
		Чем отличаются модули от «обычных» скриптов?
			Всегда «use strict»
			Своя область видимости переменных
			Код в модуле выполняется только один раз при импорте
				Если один и тот же модуль используется в нескольких местах, то его код выполнится только один раз, после чего экспортируемая функциональность передаётся всем импортёрам.
					// Импорт одного и того же модуля в разных файлах
					// 📁 1.js
					import `./alert.js`; // Модуль выполнен!
					// 📁 2.js
					import `./alert.js`; // (ничего не покажет)
				Давайте представим, что модуль экспортирует объект:
					// 📁 admin.js
					export let admin = {
						name: "John"
					};
				Если модуль импортируется в нескольких файлах, то код модуля будет выполнен только один раз, объект admin будет создан и в дальнейшем будет передан всем импортёрам.
				Все импортёры получат один-единственный объект admin:
					// 📁 1.js
					import {admin} from './admin.js';
					admin.name = "Pete";
					// 📁 2.js
					import {admin} from './admin.js';
					alert(admin.name); // Pete
					// Оба файла, 1.js и 2.js, импортируют один и тот же объект
					// Изменения, сделанные в 1.js, будут видны в 2.js
			import.meta
				Объект import.meta содержит информацию о текущем модуле.
			В модуле «this» не определён
				В модуле на верхнем уровне this не определён (undefined).
				Сравним с не-модульными скриптами, там this – глобальный объект:
				<script>
					alert(this); // window
				</script>
				<script type="module">
					alert(this); // undefined
				</script>
				
	Особенности в браузерах
		https://learn.javascript.ru/modules-intro#osobennosti-v-brauzerah

Экспорт и импорт
	Мы можем пометить любое объявление как экспортируемое, разместив export перед ним, будь то переменная, функция или класс.
	Например, все следующие экспорты допустимы:
		// экспорт массива
		export let months = ['Jan', 'Feb', 'Mar', 'Apr', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
		// экспорт константы
		export const MODULES_BECAME_STANDARD_YEAR = 2015;
		// экспорт класса
		export class User {
			constructor(name) {
				this.name = name;
			}
		}
	Не ставится точка с запятой после экспорта класса/функции
	
	Экспорт отдельно от объявления
		Также можно написать export отдельно.
			// 📁 say.js
			function sayHi(user) {
				alert(`Hello, ${user}!`);
			}
			function sayBye(user) {
				alert(`Bye, ${user}!`);
			}
			export {sayHi, sayBye}; // список экспортируемых переменных
		
	Импорт *
		Обычно мы располагаем список того, что хотим импортировать, в фигурных скобках import {...}, например вот так:
			// 📁 main.js
			import {sayHi, sayBye} from './say.js';
			sayHi('John'); // Hello, John!
			sayBye('John'); // Bye, John!
		Но если импортировать нужно много чего, мы можем импортировать всё сразу в виде объекта, используя import * as <obj>. Например:
			// 📁 main.js
			import * as say from './say.js';

			say.sayHi('John');
			say.sayBye('John');
		Есть несколько причин использовать import {...}.
			1. Современные инструменты сборки (webpack и другие) собирают модули вместе и оптимизируют их, ускоряя загрузку и удаляя неиспользуемый код.
			2. Предположим, мы добавили в наш проект стороннюю библиотеку say.js с множеством функций:
						// 📁 say.js
						export function sayHi() { ... }
						export function sayBye() { ... }
						export function becomeSilent() { ... }
				 Теперь, если из этой библиотеки в проекте мы используем только одну функцию:
						// 📁 main.js
						import {sayHi} from './say.js';
				 …Тогда оптимизатор увидит, что другие функции не используются, и удалит остальные из собранного кода, тем самым делая код меньше. Это называется «tree-shaking».
			3. Явно перечисляя то, что хотим импортировать, мы получаем более короткие имена функций: sayHi() вместо say.sayHi().
			4. Явное перечисление импортов делает код более понятным, позволяет увидеть, что именно и где используется. Это упрощает поддержку и рефакторинг кода.
	
	Импорт «как»
		Мы также можем использовать as, чтобы импортировать под другими именами.
		Например, для краткости импортируем sayHi в локальную переменную hi, а sayBye импортируем как bye:
			// 📁 main.js
			import {sayHi as hi, sayBye as bye} from './say.js';
	
	Экспорт по умолчанию
		На практике модули встречаются в основном одного из двух типов:
			1. Модуль, содержащий библиотеку или набор функций, как say.js выше.
			2. Модуль, который объявляет что-то одно, например модуль user.js экспортирует только class User.
		Модули предоставляют специальный синтаксис export default («экспорт по умолчанию») для второго подхода.
		Ставим export default перед тем, что нужно экспортировать:
			// 📁 user.js
			export default class User { // просто добавьте "default"
				constructor(name) {
					this.name = name;
				}
			}
		Заметим, в файле может быть не более одного export default.
		
		…И потом импортируем без фигурных скобок:
			// 📁 main.js
			import User from './user.js'; // не {User}, просто User
			new User('John');
			
		Запомним: фигурные скобки необходимы в случае именованных экспортов, для export default они не нужны.

		Технически в одном модуле может быть как экспорт по умолчанию, так и именованные экспорты, но на практике обычно их не смешивают. 
			
		Имя «default»
			В некоторых ситуациях для обозначения экспорта по умолчанию в качестве имени используется default.
			Например, чтобы экспортировать функцию отдельно от её объявления:
				function sayHi(user) {
					alert(`Hello, ${user}!`);
				}
				// то же самое, как если бы мы добавили "export default" перед функцией
				export {sayHi as default};
				
			И, наконец, если мы импортируем всё как объект import *, тогда его свойство default – как раз и будет экспортом по умолчанию:
				// 📁 main.js
				import * as user from './user.js';
				let User = user.default; // экспорт по умолчанию
				new User('John');
		
		Довод против экспортов по умолчанию
			Именованные экспорты «включают в себя» своё имя. Эта информация является частью модуля, говорит нам, что именно экспортируется.
			Именованные экспорты вынуждают нас использовать правильное имя при импорте:
				import {User} from './user.js';
				// import {MyUser} не сработает, должно быть именно имя {User}
				
			…В то время как для экспорта по умолчанию мы выбираем любое имя при импорте:
				import User from './user.js'; // сработает
				import MyUser from './user.js'; // тоже сработает
			Обычно, чтобы избежать этого и соблюсти единообразие кода, есть правило: имена импортируемых переменных должны соответствовать именам файлов.
			
	Реэкспорт
		Синтаксис «реэкспорта» export ... from ... позволяет импортировать что-то и тут же экспортировать, возможно под другим именем, вот так:
			export {sayHi} from './say.js'; // реэкспортировать sayHi
			export {default as User} from './user.js'; // реэкспортировать default
		Запись export ... from ...– это просто более короткий вариант такого импорта-экспорта:
			// импортировать login/logout и тут же экспортировать
			import {login, logout} from './helpers.js';
			export {login, logout};
			
		Реэкспорт экспорта по умолчанию
			https://learn.javascript.ru/import-export#reeksport-eksporta-po-umolchaniyu

Динамические импорты
	Инструкции экспорта и импорта, которые мы рассматривали в предыдущей главе, называются «статическими».
		Во-первых, мы не можем динамически задавать никакие из параметров import.
		Путь к модулю должен быть строковым примитивом и не может быть вызовом функции. Вот так работать не будет:
			import ... from getModuleName(); // Ошибка, должна быть строка
		Во-вторых, мы не можем делать импорт в зависимости от условий или в процессе выполнения.
			if(...) {
				import ...; // Ошибка, запрещено
			}

			{
				import ...; // Ошибка, мы не можем ставить импорт в блок
			}
	Но как мы можем импортировать модуль динамически, по запросу?

	Выражение import()
		Выражение import(module) загружает модуль и возвращает промис, результатом которого становится объект модуля, содержащий все его экспорты.
		Использовать его мы можем динамически в любом месте кода, например, так:
			let modulePath = prompt("Какой модуль загружать?");

			import(modulePath)
				.then(obj => <объект модуля>)
				.catch(err => <ошибка загрузки, например если нет такого модуля>)
		Или если внутри асинхронной функции, то можно let module = await import(modulePath).
		
		Хотя import() и выглядит похоже на вызов функции, на самом деле это специальный синтаксис, так же, как, например, super().
		Так что мы не можем скопировать import в другую переменную или вызвать при помощи .call/apply. Это не функция.
		
Proxy и Reflect
	Proxy «оборачивается» вокруг другого объекта и может перехватывать разные действия с ним, например чтение/запись свойств и другие. 
	Далее мы будем называть такие объекты «прокси».
			let proxy = new Proxy(target, handler);
		* target – это объект, для которого нужно сделать прокси, может быть чем угодно, включая функции.
		* handler – конфигурация прокси: объект с «ловушками» («traps»): методами, которые перехватывают разные операции, например, ловушка get – для чтения свойства из target, ловушка set – для записи свойства в target и так далее.
	В качестве начального примера создадим прокси без всяких ловушек:
			let target = {};
			let proxy = new Proxy(target, {}); // пустой handler
	Proxy – это особый, «экзотический», объект, у него нет собственных свойств. С пустым handler он просто перенаправляет все операции на target.
	
	Для большинства действий с объектами в спецификации JavaScript есть так называемый «внутренний метод», который на самом низком уровне описывает, как его выполнять.
	Например, [[Get]] – внутренний метод для чтения свойства, [[Set]] – для записи свойства, и так далее. Эти методы используются только в спецификации, мы не можем обратиться напрямую к ним по имени.
		
	JavaScript налагает некоторые условия – инварианты на реализацию внутренних методов и ловушек.
	Большинство из них касаются возвращаемых значений:
		Метод [[Set]] должен возвращать true, если значение было успешно записано, иначе false.
		Метод [[Delete]] должен возвращать true, если значение было успешно удалено, иначе false.
		…и так далее, мы увидим больше в примерах ниже.
		
	Значение по умолчанию с ловушкой «get»
		Чаще всего используются ловушки на чтение/запись свойств.

		Чтобы перехватить операцию чтения, handler должен иметь метод get(target, property, receiver).
		Он срабатывает при попытке прочитать свойство объекта, с аргументами:
			target – это оригинальный объект, который передавался первым аргументом в конструктор new Proxy,
			property – имя свойства,
			receiver – если свойство объекта является геттером, то receiver – это объект, который будет использован как this при его вызове.
		
		Например, сделаем числовой массив, так чтобы при чтении из него несуществующего элемента возвращался 0.
			let numbers = [0, 1, 2];
			numbers = new Proxy(numbers, {
				get(target, prop) {
					if (prop in target) {
						return target[prop];
					} else {
						return 0; // значение по умолчанию
					}
				}
			});

			alert( numbers[1] ); // 1
			alert( numbers[123] ); // 0 (нет такого элемента)
				
		Прокси следует использовать везде вместо target
		Пожалуйста, обратите внимание: прокси перезаписывает переменную:
			let dictionary = {
				'Hello': 'Hola',
				'Bye': 'Adiós'
			};
			dictionary = new Proxy(dictionary, ...);
		Прокси должен заменить собой оригинальный объект повсюду. Никто не должен ссылаться на оригинальный объект после того, как он был проксирован. Иначе очень легко запутаться.
		
	Валидация с ловушкой «set»
		Допустим, мы хотим сделать массив исключительно для чисел. Если в него добавляется значение иного типа, то это должно приводить к ошибке.
		Ловушка set срабатывает, когда происходит запись свойства.
		set(target, property, value, receiver):
			target – это оригинальный объект, который передавался первым аргументом в конструктор new Proxy,
			property – имя свойства,
			value – значение свойства,
			receiver – аналогично ловушке get, этот аргумент имеет значение, только если свойство – сеттер.
		
		Ловушка set должна вернуть true, если запись прошла успешно, и false в противном случае (будет сгенерирована ошибка TypeError).
			numbers = new Proxy(numbers, { // (*)
				set(target, prop, val) { // для перехвата записи свойства
					if (typeof val == 'number') {
						target[prop] = val;
						return true;
					} else {
						return false;
					}
				}
			});
			numbers.push(1); // добавилось успешно
			numbers.length; // 2
			numbers.push("тест"); // TypeError (ловушка set на прокси вернула false)
		Обратите внимание, что встроенная функциональность массива по-прежнему работает! Значения добавляются методом push. Свойство length при этом увеличивается. Наш прокси ничего не ломает.
		Нам не нужно переопределять методы массива push и unshift и другие, чтобы добавлять туда проверку на тип, так как внутри себя они используют операцию [[Set]], которая перехватывается прокси.
	
	Перебор при помощи «ownKeys» и «getOwnPropertyDescriptor»
		https://learn.javascript.ru/proxy#perebor-pri-pomoschi-ownkeys-i-getownpropertydescriptor
		
	Защищённые свойства с ловушкой «deleteProperty» и другими
		https://learn.javascript.ru/proxy#perebor-pri-pomoschi-ownkeys-i-getownpropertydescriptor
		
	«В диапазоне» с ловушкой «has»
		https://learn.javascript.ru/proxy#v-diapazone-s-lovushkoy-has
	
	Оборачиваем функции: «apply»
		https://learn.javascript.ru/proxy#oborachivaem-funktsii-apply
		
	Reflect
		https://learn.javascript.ru/proxy#reflect
		
	Ограничения прокси
		https://learn.javascript.ru/proxy#ogranicheniya-proksi
	
	Отключаемые прокси
		https://learn.javascript.ru/proxy#otklyuchaemye-proksi
		
Eval: выполнение строки кода
	Встроенная функция eval позволяет выполнять строку кода.
	Синтаксис:
		let result = eval(code);
	Например:
		let code = 'alert("Привет")';
		eval(code); // Привет
		
	Результатом eval будет результат выполнения последней инструкции.
		let value = eval('let i = 0; ++i');
		alert(value); // 1
		
	Код в eval выполняется в текущем лексическом окружении, поэтому ему доступны внешние переменные:
		let a = 1;
		function f() {
			let a = 2;
			eval('alert(a)'); // 2
		}
		f();
	
	Значения внешних переменных можно изменять:
		let x = 5;
		eval("x = 10");
		alert(x); // 10, значение изменено
	
	В строгом режиме у eval имеется своё лексическое окружение. Поэтому функции и переменные, объявленные внутри eval, нельзя увидеть снаружи:
	Без use strict у eval не будет отдельного лексического окружения, поэтому x и f будут видны из внешнего кода.
	
	Использование «eval»
		В современной разработке на JavaScript eval используется весьма редко.
		Использование внутри eval локальных переменных из внешнего кода считается плохим решением, так как это усложняет задачу по поддержке такого кода.
		Существует два пути, как гарантированно избежать подобных проблем.
			Если код внутри eval не использует внешние переменные, то вызывайте его так – window.eval(...):
			В этом случае код выполняется в глобальной области видимости:
				let x = 1;
				{
					let x = 5;
					window.eval('alert(x)'); // 1 (глобальная переменная)
				}
			Если коду внутри eval нужны локальные переменные, поменяйте eval на new Function и передавайте необходимые данные как аргументы:
				let f = new Function('a', 'alert(a)');
				f(5); // 5

Каррирование
	Каррирование – это трансформация функций таким образом, чтобы они принимали аргументы не как f(a, b, c), а как f(a)(b)(c).
	Каррирование не вызывает функцию. Оно просто трансформирует её.
	Создадим вспомогательную функцию curry(f), которая выполняет каррирование функции f с двумя аргументами. Другими словами, curry(f) для функции f(a, b) трансформирует её в f(a)(b).
		function curry(f) { // curry(f) выполняет каррирование
			return function(a) {
				return function(b) {
				  return f(a, b);
				};
			};
		}

		// использование
		function sum(a, b) {
			return a + b;
		}

		let curriedSum = curry(sum);

		alert( curriedSum(1)(2) ); // 3
	
	Как вы видите, реализация довольна проста: это две обёртки.
	Результат curry(func) – обёртка function(a).
	Когда она вызывается как sum(1), аргумент сохраняется в лексическом окружении и возвращается новая обёртка function(b).
	Далее уже эта обёртка вызывается с аргументом 2 и передаёт вызов к оригинальной функции sum.
	
	Каррирование? Зачем?
		https://learn.javascript.ru/currying-partials#karrirovanie-zachem
		
	Продвинутая реализация каррирования
		https://learn.javascript.ru/currying-partials#prodvinutaya-realizatsiya-karrirovaniya

Ссылочный тип
	Некоторые хитрые способы вызова метода приводят к потере значения this, например:
		let user = {
			name: "Джон",
			hi() { alert(this.name); },
			bye() { alert("Пока"); }
		};

		user.hi(); // Джон (простой вызов метода работает хорошо)
		(user.name == "Джон" ? user.hi : user.bye)(); // Ошибка!
		
	Ссылочный тип: объяснение
		Присмотревшись поближе, в выражении obj.method() можно заметить две операции:
			Сначала оператор точка '.' возвращает свойство объекта – его метод (obj.method).
			Затем скобки () вызывают этот метод (исполняется код метода).
		
		Итак, каким же образом информация о this передаётся из первой части во вторую?
		Если мы поместим эти операции в отдельные строки, то значение this, естественно, будет потеряно:
			let user = {
				name: "John",
				hi() { alert(this.name); }
			};

			// разделим получение метода объекта и его вызов в разных строках
			let hi = user.hi;
			hi(); // Ошибка, потому что значением this является undefined
		Здесь hi = user.hi сохраняет функцию в переменной, и далее в последней строке она вызывается полностью сама по себе, без объекта, так что нет this.
		Для работы вызовов типа user.hi(), JavaScript использует трюк – точка '.' возвращает не саму функцию, а специальное значение «ссылочного типа», называемого Reference Type.
		Этот ссылочный тип (Reference Type) является внутренним типом. Мы не можем явно использовать его, но он используется внутри языка.
		Значение ссылочного типа – это «триплет»: комбинация из трёх значений (base, name, strict), где:
			base – это объект.
			name – это имя свойства объекта.
			strict – это режим исполнения. Является true, если действует строгий режим (use strict).
		Результатом доступа к свойству user.hi является не функция, а значение ссылочного типа. Для user.hi в строгом режиме оно будет таким:
			// значение ссылочного типа (Reference Type)
			(user, "hi", true)
		
		При любой другой операции, например, присваивании hi = user.hi, ссылочный тип заменяется на собственно значение user.hi (функцию), и дальше работа уже идёт только с ней. Поэтому дальнейший вызов происходит уже без this.
		
		Таким образом, значение this передаётся правильно, только если функция вызывается напрямую с использованием синтаксиса точки obj.method() или квадратных скобок obj['method']()

Побитовые операторы
	https://learn.javascript.ru/bitwise-operators#primenenie-pobitovyh-operatorov

BigInt
	BigInt – это специальный числовой тип, который предоставляет возможность работать с целыми числами произвольной длины.
		const bigint = 1234567890123456789012345678901234567890n;
		const sameBigint = BigInt("1234567890123456789012345678901234567890");
		const bigintFromNumber = BigInt(10); // то же самое, что и 10n
	
	Математические операторы
		BigInt можно использовать как обычные числа, к примеру:
			alert(1n + 2n); // 3
			alert(5n / 2n); // 2
		Обратите внимание: операция деления 5/2 возвращает округлённый результат, без дробной части. Все операции с числами типа bigint возвращают bigint.
		
		В математических операциях мы не можем смешивать bigint и обычные числа:
			alert(1n + 2); // Error: Cannot mix BigInt and other types
		Мы должны явно их конвертировать: используя либо BigInt(), либо Number(), например:
		Конвертирование bigint в число всегда происходит неявно и без генерации ошибок, но если значение bigint слишком велико и не подходит под тип number, то дополнительные биты будут отброшены, так что следует быть осторожными с такими преобразованиями.
		
		К BigInt числам нельзя применить унарный оператор +
		Унарный оператор +value является хорошо известным способом конвертировать произвольное значение value в число.
		Данный оператор не поддерживается при работе с BigInt числами.
			let bigint = 1n;
			alert( +bigint ); // SyntaxError: Unexpected identifier
			
	Операции сравнения
		Операции сравнения, такие как <, >, работают с bigint и обычными числами как обычно:
			alert( 2n > 1n ); // true
			alert( 2n > 1 ); // true
		Пожалуйста, обратите внимание, что обычные и bigint числа принадлежат к разным типам, они могут быть равны только при нестрогом сравнении ==
		
	Логические операции
		В if или любом другом логическом операторе bigint число ведёт себя как обычное число.
	
	Полифилы
		https://learn.javascript.ru/bigint
		
Юникод, внутреннее устройство строк
	https://learn.javascript.ru/unicode
	
Intl: интернационализация в JavaScript
	Общая проблема строк, дат, чисел в JavaScript – они «не в курсе» языка и особенностей стран, где находится посетитель.
	В частности:
		Строки
		При сравнении сравниваются коды символов, а это неправильно, к примеру, в русском языке оказывается, что "ё" > "я" и "а" > "Я"
	
	Основные объекты
		Intl.Collator
			Умеет правильно сравнивать и сортировать строки.
		Intl.DateTimeFormat
			Умеет форматировать дату и время в соответствии с нужным языком.
		Intl.NumberFormat
			Умеет форматировать числа в соответствии с нужным языком.
		
	Локаль
		Локаль – первый и самый важный аргумент всех методов, связанных с интернационализацией.
		Локаль описывается строкой из трёх компонентов, которые разделяются дефисом:
			1. Код языка.
			2. Код способа записи.
			3. Код страны.
		На практике не всегда указаны три, обычно меньше:
			1. ru – русский язык, без уточнений.
			2. en-GB – английский язык, используемый в Англии (GB).
			3. en-US – английский язык, используемый в США (US).
		
		Стандарт, который описывает локали – RFC 5646, языки описаны в IANA language registry.
		
	Подбор локали localeMatcher
		localeMatcher – вспомогательная настройка, которую тоже можно везде указать, она определяет способ подбора локали, если желаемая недоступна.

		У него два значения:
			"lookup" – означает простейший порядок поиска путём обрезания суффикса, например zh-Hans-CN → zh-Hans → zh → локаль по умолчанию.
			"best fit" – использует встроенные алгоритмы и предпочтения браузера (или другого окружения) для выбора подходящей локали.
		
		Если локалей несколько, например ["zh-Hans-CN", "ru-RU"] то localeMatcher пытается подобрать наиболее подходящую локаль для первой из списка (китайская), если не получается – переходит ко второй (русской) и так далее. Если ни одной не нашёл, например на компьютере не совсем поддерживается ни китайский ни русский, то используется локаль по умолчанию.
	
	Строки, Intl.Collator
		https://learn.javascript.ru/intl#intl-collator
		
	Даты, Intl.DateTimeFormat
		https://learn.javascript.ru/intl#intl-datetimeformat
	
	Числа, Intl.NumberFormat
		https://learn.javascript.ru/intl#chisla-intl-numberformat
	
	Методы в Date, String, Number
		https://learn.javascript.ru/intl#metody-v-date-string-number

				
		
		

Классы
	https://learn.javascript.ru/classes
			
HZ Куда вставлять:
	JS - ||=, ??=. **=
	
Вопросы:

	2. Нужен ли Symbol.iterator
	3. Потраить Трансформацию объекта
	4. Поприкалываться с деструктурирующим присваиванием

	6. Синтаксис "new Function", потраить :)
	7. Минификатор JS
	8. Потраить геттеры и сеттеры у объектов
	9. try catch
	10. Кэширование => Где используется WeakMap, WeakSet

	12. Полифил
	13. Зачем нужен динамический импорт js
	14. Как и где использовать Proxy и Reflect?
	15. Почему не стоит использовать eval?
	16. Когда использовать каррирование
	17. Нужны ли побитовые операторы?
	18. localeMatcher - js
	19. сериализация js
	20. hashmap js
	21. Мономорфизм
	23. Генераторы и Symbol.Iterator JS
	
	
	
/* Will match
	<div data-state="open"></div>
	<div data-state="Open"></div>
	<div data-state="OPEN"></div>
	<div data-state="oPeN"></div>
*/
[data-state="open" i] { }
