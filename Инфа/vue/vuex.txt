https://openclassrooms.com/en/courses/5664336-create-a-web-application-with-vue-js/6536349-make-changes-to-data-in-vuex

Vuex — state management pattern + библиотека

В центре любого Vuex-приложения находится store.
"store" — это контейнер, в котором хранится state вашего приложения.

Два момента отличают хранилище Vuex от простого глобального объекта:
  1. Хранилище Vuex реактивно.
  2. Нельзя напрямую изменять state хранилища. Единственный способ внести изменения — явно вызвать мутацию.

state:
  Vuex использует единое дерево состояния — когда один объект содержит всё глобальное состояние приложения и служит «единственным источником истины».
  Это также означает, что в приложении будет только одно такое хранилище.

  Важно!
  --
  Данные, которые хранятся во Vuex должны следовать тем же правилам, что и data в экземпляре Vue, т.е. объект состояния должен быть простым.
  --

  Как использовать state хранилища в компонентах Vue?
  Поскольку хранилище Vuex реактивно, самый простой способ «получения» — просто вернуть часть состояния хранилища в computed:
    computed: {
      count() {
        return store.state.count;
      }
    }
  Любые изменения store.state.count вызовут перерасчёт вычисляемого свойства и запуск связанных с ним обновлений DOM.
  Однако этот паттерн заставляет компонент полагаться на синглтон глобального хранилища. (как решить читать ниже)

  Vuex предоставляет механизм «внедрения» хранилища во всех дочерних компонентах корневого компонента, у которого указана опция store:
    const app = new Vue({
      el: '#app',
      // указываем хранилище в опции «store», что обеспечит
      // доступ к нему также и во всех дочерних компонентах
      store,
      components: { Counter },
      template: `
        <div class="app">
          <counter></counter>
        </div>
      `
    });
  Указывая опцию store в корневом экземпляре, мы обеспечиваем доступ к хранилищу во всех дочерних компонентах через this.$store:
    computed: {
      count() {
        return this.$store.state.count;
      }
    }

  mapState - автоматически генерирует вычисляемые свойства:
    computed: mapState({
      // стрелочные функции могут сделать код очень кратким
      count: state => state.count,

      // передача строки 'count' аналогична записи `state => state.count`
      countAlias: 'count',

      // для доступа к локальному состоянию через `this`,
      // необходимо использовать обычную функцию
      countPlusLocalState(state) {
        return state.count + this.localCount;
      }
    })
    # ИЛИ
    computed: mapState([
      // проксирует в this.count доступ к store.state.count
      'count'
    ]);

getter:
  Иногда может потребоваться вычислять производное состояние на основе состояния хранилища, например, отфильтровать список
  и затем подсчитать количество элементов:
    computed: {
      doneTodosCount () {
        return this.$store.state.todos.filter(todo => todo.done).length
      }
    }
  Если такие вычисления потребуются более чем в одном компонент, Vuex позволяет определять «геттеры» в хранилище.
  Можете считать их computed свойствами хранилища.
  Как и computed свойства, результаты getter 'кэшируются', на основе его зависимостей и пересчитываются только при изменении одной из зависимостей.

  Геттеры получают состояние хранилища первым аргументом
  Вторым аргументом передаются другие геттеры:
    getters: {
      doneTodosCount: (state, getters) => {
        return getters.doneTodos.length;
      }
    }
  Обратите внимание, что геттеры, доступ к которым выполняется как к свойствам, будут кэшироваться как часть системы реактивности Vue.

  Можно также передавать аргументы геттерам, возвращая функцию:
    getters: {
      getTodoById: (state) => (id) => {
        return state.todos.find(todo => todo.id === id)
      }
    }
    store.getters.getTodoById(2)

  mapGetters - проксирует геттеры хранилища в локальные вычисляемые свойства компонента
    computed: {
      ...mapGetters([
        'doneTodosCount',
        'anotherGetter'
        // ...
      ])
    }

mutations:
  Единственным способом изменения состояния хранилища во Vuex являются мутации.
  В этом обработчике и происходят, собственно, изменения состояния, переданного в функцию первым аргументом:
    mutations: {
      increment(state) {
        // изменяем состояние
        state.count++;
      }
    }

  Вызывать функцию-обработчик напрямую — нельзя.
  Чтобы инициировать обработку мутации, необходимо вызвать store.commit, указав её тип:
    store.commit('increment')

  При вызове store.commit в мутацию можно также передать дополнительный параметр, называемый (payload):
    mutations: {
      increment (state, n) {
        state.count += n
      }
    }
    store.commit('increment', 10);
  В большинстве случаев нагрузка будет объектом, содержащим несколько полей. (прост вставил чтобы понимать что такой метод написания приемлем)

  Другой способ вызвать мутацию — это передать в commit единственный параметр, в котором type указан напрямую:
    store.commit({
      type: 'increment',
      amount: 10
    });

  Поскольку state хранилища Vuex — это реактивная переменная Vue, при возникновении mutation зависящие от этого state
  компоненты Vue обновляются автоматически.
  Кроме того, это значит, что мутации Vuex имеют те же самые подводные камни, что и реактивность в обычном Vue:
    1. Лучше инициализировать изначальное состояние хранилища, указав все поля в самом начале.
    2. При добавлении новых свойств объекту необходимо либо:
      • Использовать Vue.set(obj, 'newProp', 123), или
      • Целиком заменить старый объект новым.

  Важно!
  --
    Нужно помнить одно важное правило: обработчики мутаций обязаны быть синхронными.
    Почему? Рассмотрим пример:
      mutations: {
        someMutation (state) {
          api.callAsyncMethod(() => {
            state.count++
          })
        }
      }
    Теперь представьте, что вы отлаживаете приложение и смотрите в лог мутаций в инструментах разработчика.
    Для каждой залогированной мутации devtools должен сохранить слепки состояния приложения "до" и "после" её наступления.
    Однако, асинхронный коллбэк внутри приведённой выше мутации делает это невозможным: мутация-то уже записана,
    и у devtools нет никакой возможности знать, что далее будет вызван коллбэк, а, значит, и инициируемые им изменения становится,
    по сути дела, невозможно отследить.

    Если коротко, то мутации должны быть легкоотслеживаемыми, а асинрон этому мешает
  --

  this.$store.commit('xxx') - вызывать mutation из кода компонентов

  mapMutations - проксирует вызовы store.commit через методы компонентов

actions:
  actions — похожи на mutations с несколькими отличиями:
    1. Вместо того, чтобы напрямую менять state, действия инициируют mutation;
    2. actions могут использоваться для асинхронных операций.

    Обработчики действий получают объект контекста, содержащий те же методы и свойства, что и сам экземпляр хранилища,
    так что вы можете вызвать:
      context.commit
      context.state
      context.getters.
    На практике для упрощения кода часто используется деструктуризация аргументов
    actions: {
      increment ({ commit }) {
        commit('increment')
      }
    }

    Действия запускаются методом store.dispatch:
      store.dispatch('increment')

    Действия поддерживают тот же формат для передачи payload, а также объектный синтаксис:
      store.dispatch({
        type: 'incrementAsync',
        amount: 10
      });

    this.$store.dispatch('xxx')
    mapActions

    Первое, что нужно знать — store.dispatch может обрабатывать Promise, возвращаемый обработчиком действия, и также возвращает Promise:
      actions: {
        actionA ({ commit }) {
          return new Promise((resolve, reject) => {
            setTimeout(() => {
              commit('someMutation')
              resolve()
            }, 1000)
          })
        }
      }
      Теперь можно сделать так:
      store.dispatch('actionA').then(() => {
        // ...
      });

    Важно!
    --
      store.dispatch может вызывать несколько обработчиков действий в различных модулях одновременно.
      В этом случае возвращаемым значением будет Promise, разрешающийся после разрешения всех вызванных обработчиков.
    --

modules:
  Vuex позволяет разделять store на module.
  Каждый module может содержать собственное state, mutations, actions, getters и даже встроенные mutations:
    const moduleA = {
      state: () => ({ ... }),
      mutations: { ... },
      actions: { ... },
      getters: { ... }
    }
    const moduleB = {
      state: () => ({ ... }),
      mutations: { ... },
      actions: { ... }
    }
    const store = new Vuex.Store({
      modules: {
        a: moduleA,
        b: moduleB
      }
    })
    store.state.a // -> состояние модуля `moduleA`
    store.state.b // -> состояние модуля `moduleB`

  Первым аргументом, который получает мутации и геттеры, будет локальное состояние модуля:
    mutations: {
      increment(state) {
        // `state` указывает на локальное состояние модуля
        state.count++;
      }
    },
    getters: {
      doubleCount(state) {
        return state.count * 2;
      }
    }

  Важно!
  --
    Аналогично, context.state в actions также указывает на локальное состояние module, а корневое — доступно в context.rootState:
    Кроме того, в геттеры корневое состояние передаётся 3-м параметром:
      getters: {
        sumWithRootCount(state, getters, rootState) {
          return state.count + rootState.count;
        }
      }
  --

  Важно!
  --
    actions и mutations внутри module по умолчанию регистрируются в глобальном пространстве имён —
    это позволяет нескольким modules реагировать на один и тот же тип actions/mutations.
    getters также по умолчанию регистрируются в глобальном пространстве имён.
    Однако, в настоящее время у этого нет функционального значения.
    Поэтому следует быть осторожным, чтобы не определить два getters с одинаковыми именами в разных modules, что приведёт к ошибкам.

    Если вы хотите сделать modules более самодостаточными и готовыми для переиспользования,
    вы можете создать его с собственным пространством имён, указав опцию 'namespaced: true'.
      account: {
        namespaced: true,
        // содержимое модуля
        state: () => ({ ... }), // состояние модуля автоматически вложено и не зависит от опции пространства имён
        getters: {
          isAdmin () { ... } // -> getters['account/isAdmin']
        },
        actions: {
          login () { ... } // -> dispatch('account/login')
        },
        mutations: {
          login () { ... } // -> commit('account/login')
        },
        // вложенные модули
        modules: {
          // наследует пространство имён из родительского модуля
          myPage: {
            state: () => ({ ... }),
            getters: {
              profile () { ... } // -> getters['account/profile']
            }
          },
          // большая вложенность с собственным пространством имён
          posts: {
            namespaced: true,

            state: () => ({ ... }),
            getters: {
              popular () { ... } // -> getters['account/posts/popular']
            }
          }
        }
      }

    Геттеры и действия с собственным пространством имён будут получать свои локальные getters, dispatch и commit.
    Другими словами, вы можете использовать содержимое модуля без написания префиксов в том же модуле.
  --

  Если вы хотите использовать глобальное state и getters, rootState и rootGetters передаются 3-м и 4-м аргументами в функции getters,
  а также как свойства в объекте context, передаваемом в функции actions.

  Если вы хотите зарегистрировать глобальное действие в модуле с собственным пространством имён, вы можете пометить его
  с помощью root: true и поместить определение действия в функцию handler. Например:
  actions: {
    someAction: {
      root: true,
      handler (namespacedContext, payload) { ... } // -> 'someAction'
    }
  }

  Подключение модуля со своим пространством имён к компонентам с помощью вспомогательных функций mapState, mapGetters, mapActions и mapMutations:
    ...mapState({
      a: state => state.some.nested.module.a,
      b: state => state.some.nested.module.b
    }),
    ...mapGetters([
      'some/nested/module/someGetter', // -> this['some/nested/module/someGetter']
      'some/nested/module/someOtherGetter', // -> this['some/nested/module/someOtherGetter']
    ])
  ИЛИ
    ...mapState('some/nested/module', {
      a: state => state.a,
      b: state => state.b
    }),
    ...mapGetters('some/nested/module', [
      'someGetter', // -> this.someGetter
      'someOtherGetter', // -> this.someOtherGetter
    ])

  Важно!
  --
  Кроме того, вы можете создать вспомогательные функции с помощью createNamespacedHelpers. Она возвращает объект,
  в котором все вспомогательные функции для связывания с компонентами будут указывать на переданное пространство имён:
    import { createNamespacedHelpers } from 'vuex';
    const { mapState, mapActions } = createNamespacedHelpers('some/nested/module');
    export default {
      computed: {
        // будет указывать на `some/nested/module`
        ...mapState({
          a: state => state.a,
          b: state => state.b
        })
      },
      methods: {
        // будет указывать на `some/nested/module`
        ...mapActions(['foo', 'bar'])
      }
  --

  Важно!
  --
  Вы можете зарегистрировать модуль уже и после того, как хранилище было создано, используя метод store.registerModule:
    const store = new Vuex.Store({ /* опции */ })
    // регистрация вложенного модуля `nested/myModule`
    store.registerModule(['nested', 'myModule'], {
      // ...
    });
  --
  Состояние модуля будет доступно как store.state.myModule и store.state.nested.myModule.
  Обратите внимание, что можно проверить, зарегистрирован ли уже модуль с заданным именем с помощью метода store.hasModule(moduleName).

  Повторное использование модулей:
    https://v3.vuex.vuejs.org/ru/guide/modules.html#%D0%BF%D0%BE%D0%B2%D1%82%D0%BE%D1%80%D0%BD%D0%BE%D0%B5-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D0%B5%D0%B8

Структура приложения:
  В действительности Vuex не накладывает каких-то значительных ограничений на используемую структуру кода.
  Однако, он требует соблюдения нескольких высокоуровневых принципов:
    1. Глобальное состояние приложения должно содержаться в глобальном хранилище;
    2. Единственным механизмом изменения этого состояния являются мутации, являющиеся синхронными транзакциями;
    3. Асинхронные операции инкапсулируются в действия или их комбинации.
  Покуда вы следуете этим правилам, можно использовать любую структуру проекта.
  Если ваш файл хранилища становится слишком большим, просто начните выносить действия, мутации и геттеры в отдельные файлы.

Строгий режим (strict mode):
  В строгом режиме любая попытка внесения изменений в состояние Vuex, кроме мутаций, будет выбрасывать ошибку.
    strict: true
  Важно!
  --
  Не используйте строгий режим в production!
    strict: process.env.NODE_ENV !== 'production'
  --

Работа с формами:
  При использовании строгого режима Vuex может показаться неочевидным как использовать v-model с частью состояния Vuex:
  Для работы с Vuex в такой ситуации, следует привязать значение к <input> и отслеживать его изменения по событию input или change:
    <input :value="message" @input="updateMessage">
    computed: {
      ...mapState({
        message: state => state.obj.message
      })
    },
    methods: {
      updateMessage (e) {
        this.$store.commit('updateMessage', e.target.value)
      }
    }
  Заметно, что получившаяся выше запись — куда многословнее, чем используемая в связке v-model с локальным состоянием,
  да и некоторые полезные возможности v-model мы таким образом упускаем.
  В качестве альтернативы можно предложить использование двунаправленного вычисляемого свойства с сеттером:
    <input v-model="message">
    computed: {
      message: {
        get () {
          return this.$store.state.obj.message
        },
        set (value) {
          this.$store.commit('updateMessage', value)
        }
      }
    }

Горячая перезагрузка
  Vuex поддерживает горячую замену мутаций, модулей, действий и геттеров в момент разработки с помощью
  webpack Hot Module Replacement API .

API:
  https://v3.vuex.vuejs.org/ru/api/#strict

Best Practise:
  1. Always use Mutations to update a value in Vuex state.
  2.
    Каждый раз, когда вы совершаете мутацию, она должна делать только ОДНУ вещь: обновлять значение состояния.

    Каждый раз, когда вы отправляете действие, оно должно выполнить одно или несколько из следующих действий:
      (i) Получить данные из API.
      (ii) Произвести мутацию.
      (iii) Отправьте действие.

  3.
    [*]Если состояние возвращает булевое значение, лучше в начало добавить "is". Пример: isAuthUser. isAdmin
    [*]Если состояние возвращает объект/массив лучше всего писать с добавлением "get". Например: getProducts, getAdvances.
    [*]Если состояние что-то мутирует лучше добавить: set, add, remove.
      Где set - установка нового значения,
      add - добавление нового значения,
      remove - удаление значения

  4.
    Соглашение об именовании мутаций заключается в использовании заглавных букв и подчеркиваний для разделения слов.
    Это считается лучшей практикой, позволяющей четко указать, что это не обычные функции, которые следует вызывать случайным образом.
      mutations: {
        INCREASE_COUNT(state, payload) {
          state.count += Number(payload)
        }
      },
    Очевидно, что нам нужна некоторая логика, чтобы определить, когда запускать каждую мутацию.
    Чтобы учесть это, давайте обобщим наше действие следующим образом:
      mutations: {
        INCREASE_COUNT(state, amount = 1) {
          state.count += Number(amount)
        },
        DECREASE_COUNT(state, amount = 1) {
          state.count -= Number(amount)
        }
      },
      actions: {
        updateCount(context, amount) {
          if (amount >= 0) {
            context.commit('INCREASE_COUNT', amount)
          } else {
            context.commit('DECREASE_COUNT', amount)
          }
        }
      }

  5.
    Хотя технически вы можете вызывать мутации непосредственно из компонентов, я не собираюсь вам это показывать,
    поскольку это не считается лучшей практикой в приложениях Vue.js.

  6. Как именовать Store если для имени нужно больше чем одно слово?
    compare-products

  7. Naming
    State - Их имена записываются в верблюжьем регистре и указывают, что они содержат. (camelCase)
    Getter -
      начать с is — это когда возвращает логическое значение, иначе get (UPPERCASE)
    Action - название должно говорить что делает действие (UPPERCASE)

    mutation - (UPPERCASE)
      set - установка нового значения,
      add - добавление нового значения,
      remove - удаление значения

  8. Мутации
    Они должны быть синхронными (никогда не возвращать обещание)
    Не содержать никакой логики (быть чрезвычайно быстрыми),
    за исключением той, которая необходима для сохранения состояния в том виде, в котором оно должно быть
    (например, устанавливает значение по умолчанию для состояния).

    Мутации должны вызываться только actions одного и того же модуля.
    В большинстве случаев это должно быть только одно действие, вызывающее конкретную мутацию.

  9. Mutation types (Необязательно!)
    Итак, на самом деле это просто следование давней традиции называть константы по большей части заглавными буквами. Это не требуется.
    Использовать ли константы — это в основном предпочтение — это может быть полезно в больших проектах со многими разработчиками,
    но это совершенно необязательно, если они вам не нравятся.

    +
      1. Использование Mutation types позволяет легко найти и заменить все места, где используется определенная мутация.
      2. Значения Mutation types могут быть легко отслежены во время выполнения приложения. Например, при использовании
        инструментов разработчика браузера или инструментов отладки Vuex, мы можем видеть, какие мутации вызываются и когда.
    -
      1. В некоторых случаях, особенно если у вас есть простые мутации, использование Mutation types может показаться избыточным.
      2. Использование Mutation types требует определения и поддержки дополнительного кода для хранения и экспорта констант.

    https://stackoverflow.com/questions/47646176/how-to-use-vuex-types-constants-with-module-namespace

  10. v-model
      <input type="text" v-model="foobar" />
      computed: {
        foobar: {
          get() { return this.$store.state.foobar },
          set(value) { this.$store.commit('UPDATE_FOOBAR', value) }
        }
      }
    Хотя это официально рекомендуемый способ использования двусторонних computed свойств и он довольно прост и прекрасно работает,
    обработка таким образом большого количества полей формы быстро становится утомительной.
    Можно создать функцию mapFields
    https://www.elao.com/blog/dev/two-ways-binding-avec-vue-et-vuex
    Или воспользоваться библиотекой
    https://github.com/maoberlehner/vuex-map-fields

Lazy loading:
  Какие существуют способы регистрации модуля Vuex и каковы их плюсы и минусы.
  1. Static Vuex Modules:
    объявляются во время инициализации store.
      import { userAccountModule } from './modules/userAccount'
      const store = new Vuex.Store({
        modules: {
          user: userAccountModule
        }
      })
    Приведенный выше код создаст новое хранилище Vuex со статическим модулем userAccountModule.
    -
      1. Статические модули нельзя отменить (а также нельзя отложить их регистрацию)
      2. Нельзя изменить их структуру (не состояние!) после инициализации Store.

    Допустим, в нашем приложении есть панель администратора со специальным модулем Vuex.
      // store.js
      import { userAccountModule } from './modules/userAccount'
      import { adminModule } from './modules/admin'
      const store = new Vuex.Store({
        modules: {
          user: userAccountModule,
          admin: adminModule
        }
      })
    Вы можете себе представить, что такой модуль может быть довольно огромным. Несмотря на то, что дашборд будет
    использоваться лишь небольшой частью пользователей и в ограниченной области применения (скажем, по специальному маршруту /admin),
    из-за централизованной регистрации статических модулей Vuex весь его код попадет в основной пакет.

    Нам нужен способ загружать этот модуль только по маршруту /admin. Здесь статические модули не могут удовлетворить наши потребности.
  2. Dynamic modules:
    В отличие от статических, можно зарегистрировать после создания Vuex Store.
    Эта означает, что нам не нужно загружать динамический модуль при инициализации приложения, и мы можем объединить его
    в другой фрагмент кода или лениво загружать, когда это необходимо.

    Как будет выглядеть предыдущий код с динамически зарегистрированным модулем администратора.
      // store.js
      import { userAccountModule } from './modules/userAccount'
      import { adminModule } from './modules/admin'
      const store = new Vuex.Store({
        modules: {
          user: userAccountModule,
        }
      })
      store.registerModule('admin', adminModule)
    Вместо того, чтобы передавать объект adminModule непосредственно в свойство модулей нашего магазина, мы зарегистрировали его после создания магазина с помощью метода RegisterModule.
    Динамическая регистрация не требует каких-либо изменений внутри самого модуля, поэтому любой модуль Vuex можно зарегистрировать статически или динамически.

    Давайте исправим это и предоставим этот модуль только пользователям, входящим в маршрут /admin, чтобы другие не скачивали лишний код.
    Для этого мы загрузим модуль администратора в компонент маршрута /admin вместо того, чтобы импортировать и регистрировать его в store.js.
      // store.js
      import { userAccountModule } from './modules/userAccount'
      export const store = new Vuex.Store({
        modules: {
          user: userAccountModule,
        }
      })
      // Admin.vue
      import adminModule from './admin.js'
      export default {
        // other component logic
        mounted () {
          this.$store.registerModule('admin', adminModule)
        },
        beforeDestroy () {
        this.$store.unregisterModule('admin')
        }
      }
    Мы импортируем и регистрируем admin Store внутри Admin.vue (маршрут/admin) сразу после его монтирования.
    Далее в коде мы отменяем регистрацию модуля, как только пользователь выходит из панели администратора, чтобы
    предотвратить множественную регистрацию одного и того же модуля.

    ВАЖНО!
    ---
    Если вы используете режим SSR, убедитесь, что вы регистрируете модуль в подключенном хуке. В противном случае это
    может привести к утечкам памяти, поскольку хук beforeDestroy не оценивается на стороне сервера.
    ---

  Lazy loading Vuex modules:
    Допустим, у нас на Home.vue есть раздел отзывов, где мы хотим отображать положительные отзывы о наших услугах.
    Их много, поэтому мы не хотим показывать их сразу после того, как пользователь заходит на наш сайт.
    Гораздо лучше отображать их только в том случае, если пользователь этого хочет.

    Мы хотим, чтобы модуль отзывов загружался ТОЛЬКО в том случае, если пользователь нажимает кнопку, поскольку раньше он не нужен.
      const getTestimonialsModule = () => import('./testimonials.js')
      export default {
        methods: {
          showTestimonials() {
            getTestimonialsModule().then(testimonialsModule => {
              this.isModuleRegistered = true
              this.$store.registerModule('testimonials', testimonialsModule)
              this.$store.dispatch('testimonials/load')
            })
          }
        },
        beforeDestroy() {
          if (this.isModuleRegistered) this.$store.unregisterModule('testimonials')
        }
      }
    Когда нам нужно выйти из панели администратора, мы просто отменяем регистрацию ранее зарегистрированного модуля в
    хуке жизненного цикла beforeDestroy, чтобы он не дублировался, если мы снова войдем в этот маршрут.

    Если модуль нужен только на определенном маршруте, мы можем зарегистрировать его динамически в соответствующих компонентах маршрута,
    чтобы он не попадал в основной пакет.

    Вопросы:
  2. Реактивность
  2.1 мутации Vuex имеют те же самые подводные камни, что и реактивность в обычном Vue (Что за подводные камни?)
  3. Плагины
  4. Что такое горячая перезагрузка
  5. Почему state можно изменять только в mutations
    При использовании мутаций, Vuex отслеживает изменения состояния и обновляет все компоненты, которые зависят от этого состояния.
    Это позволяет обеспечить согласованность данных в вашем приложении.
    Если бы вы могли изменять состояние напрямую, без использования мутаций, это могло бы привести к несогласованности
    данных и сложностям в отслеживании изменений.
    Поэтому, чтобы гарантировать целостность данных и предсказуемость изменений, рекомендуется изменять состояние только
    через мутации в Vuex.