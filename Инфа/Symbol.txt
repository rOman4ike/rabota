Symbol:
	Одной из причин добавления типа данных было включение приватных свойств в JavaScript.
	К символам, определенным в глобальном реестре символов, можно обращаться с помощью Symbol.for(), и они будут одинаковыми.

	foo = Symbol('baz')
	foo === Symbol.for('baz') # true

	Символ JavaScript НЕ обеспечивает конфиденциальность свойств. Вы не можете полагаться на символы, чтобы скрыть что-то от пользователя вашей библиотеки. Существует метод, определенный в классе Object под названием Object.getOwnPropertySymbols()

	Кроме того, если символ назначен в глобальном реестре символов, ничто не помешает получить доступ к символу и значению его свойства.


	Хотя JS Symbol не используется широко и не решил проблему конфиденциальности свойств, мы все же можем извлечь из него пользу.

	Мы можем использовать Символ для определения некоторых метаданных об объекте. Например, мы хотим создать словарь, который мы реализуем путем добавления пар слов и определений к объекту, и по некоторым вычислительным причинам мы хотим отслеживать количество слов в словаре. Количество слов в этом случае можно считать метаданными. Это не очень ценная информация для пользователя, и пользователь может не захотеть видеть ее при итерации объекта.
		const dictionary = {
				wordCount: 1,
				'javascript': 'a programming language...'
		}
	Мы можем решить эту проблему, сохранив свойство word count в виде ключа с символом. В этом случае мы избежим проблемы случайного доступа пользователя к нему.
		const wordCountSymbol = Symbol('dictionaryWordCount')
		const dictionary = {
				'javascript': 'a programming language...',
				[wordCountSymbol]: 1
		}
	И причина, по которой символы будут использоваться чаще всего, - это, вероятно, коллизии имен свойств. Иногда мы получаем и устанавливаем свойства объектов при итерации по ним, или используем динамическое значение для доступа к свойству (с помощью нотации obj[key]) и в результате случайно мутируем свойство, которое мы никогда не хотели. Поэтому мы можем решить эту проблему, используя символы в качестве идентификаторов свойств. Случай итерации не произойдет, потому что мы никогда не сможем сесть на них во время итерации с помощью for...in

	И, конечно, такие известные символы, как Symbol.iterator или Symbol.asyncIterator, могут иметь интересные случаи использования.
	
	Как вы знаете, свойство Symbol в Object действует как частное скрытое свойство, поэтому вы можете использовать JSON.stringify(book), не заботясь о метаданных. (он их скроет)
	

	
	
const PLANET_MERCURY = 'Mercury';
const PLANET_MARS = 'Mars';
