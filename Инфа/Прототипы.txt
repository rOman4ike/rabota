С другой стороны, использование функций String/Number/Boolean без оператора new – вполне разумно и полезно.

Прототипы - это механизм, с помощью которого объекты JavaScript наследуют свойства друг от друга.

В JavaScript объекты имеют специальное скрытое свойство [[Prototype]], которое либо равно null, либо ссылается на другой объект.
Когда мы хотим прочитать свойство из object, а оно отсутствует, JavaScript автоматически берёт его из прототипа. В программировании такой механизм называется «прототипным наследованием». 

Свойство [[Prototype]] является внутренним и скрытым, но есть много способов задать его.
Одним из них является использование __proto__, например так:
	let animal = {
		eats: true
	};
	let rabbit = {
		jumps: true
		// or __proto__: animal
	};

	rabbit.__proto__ = animal;
Если мы ищем свойство в rabbit, а оно отсутствует, JavaScript автоматически берёт его из animal.

Есть только два ограничения на наследование:
	1. Ссылки не могут идти по кругу. JavaScript выдаст ошибку, если мы попытаемся назначить __proto__ по кругу.
	2. Значение __proto__ может быть объектом или null. Другие типы игнорируются.
	3. может быть только один [[Prototype]].

Свойство __proto__ — исторически обусловленный геттер/сеттер для [[Prototype]]

Прототип используется только для чтения свойств.

Значение «this»
	Неважно, где находится метод: в объекте или его прототипе. При вызове метода this — всегда объект перед точкой.
	
Цикл for…in
	Цикл for..in проходит не только по собственным, но и по унаследованным свойствам объекта.
	Если унаследованные свойства нам не нужны, то мы можем отфильтровать их при помощи встроенного метода obj.hasOwnProperty(key)
	
F.prototype
	Как мы помним, новые объекты могут быть созданы с помощью функции-конструктора new F().
	Если в F.prototype содержится объект, оператор new устанавливает его в качестве [[Prototype]] для нового объекта.
		let animal = {
			eats: true
		};

		function Rabbit(name) {
			this.name = name;
		}

		Rabbit.prototype = animal;

		let rabbit = new Rabbit("White Rabbit"); //  rabbit.__proto__ == animal

		alert( rabbit.eats ); // true
	
	F.prototype используется только в момент вызова new F()!
	
	F.prototype по умолчанию, свойство constructor:
		У каждой функции по умолчанию уже есть свойство "prototype".

		По умолчанию "prototype" – объект с единственным свойством constructor, которое ссылается на функцию-конструктор.
		Вот такой:
			function Rabbit() {}

			/* прототип по умолчанию
			Rabbit.prototype = { constructor: Rabbit };
			*/
			
		Чтобы сохранить верное свойство "constructor", мы должны добавлять/удалять/изменять свойства у прототипа по умолчанию вместо того, чтобы перезаписывать его целиком:
			function Rabbit() {}
			// Не перезаписываем Rabbit.prototype полностью,
			// а добавляем к нему свойство
			Rabbit.prototype.jumps = true


Встроенные прототипы:
	let obj = {};
	alert( obj ); // "[object Object]" ?
	Где код, который генерирует строку "[object Object]"?
	obj = {} – это то же самое, что и obj = new Object(), где Object – встроенная функция-конструктор для объектов с собственным свойством prototype, которое ссылается на огромный объект с методом toString и другими.
alert( obj ); // "[object Object]" - во что происходит когда объект конвертишь в стрингу

	Все наследуется от объектов
	Самое сложное происходит со строками, числами и булевыми значениями. Как мы помним, они не объекты.
	Но если мы попытаемся получить доступ к их свойствам, то тогда будет создан временный объект-обёртка с использованием встроенных конструкторов String, Number и Boolean, который предоставит методы и после этого исчезнет.

	Значения null и undefined не имеют объектов-обёрток
	
Изменение встроенных прототипов:
Встроенные прототипы можно изменять. Например, если добавить метод к String.prototype, метод становится доступен для всех строк:
	String.prototype.show = function() {
		alert(this);
	};

	"BOOM!".show(); // BOOM!
	
	ВАЖНО!
	В современном программировании есть только один случай, в котором одобряется изменение встроенных прототипов. Это создание полифилов.
	
Заимствование у прототипов:
	let obj = {
		0: "Hello",
		1: "world!",
		length: 2,
	};

	obj.join = Array.prototype.join;

	alert( obj.join(',') ); // Hello,world!
	
Методы прототипов, объекты без свойства __proto__:
	Свойство __proto__ считается устаревшим, и по стандарту оно должно поддерживаться только браузерами.
	Современные же методы это:
		Object.create(proto, [descriptors]) – создаёт пустой объект со свойством [[Prototype]], указанным как proto, и необязательными дескрипторами свойств descriptors.
		Object.getPrototypeOf(obj) – возвращает свойство [[Prototype]] объекта obj.
		Object.setPrototypeOf(obj, proto) – устанавливает свойство [[Prototype]] объекта obj как proto.
	Например:
		let animal = {
			eats: true
		};

		// создаём новый объект с прототипом animal
		let rabbit = Object.create(animal, {
			jumps: {
				value: true
			}
		});

		alert(rabbit.eats); // true

		alert(Object.getPrototypeOf(rabbit) === animal); // получаем прототип объекта rabbit

		Object.setPrototypeOf(rabbit, {}); // заменяем прототип объекта rabbit на {}
		
	Не меняйте [[Prototype]] существующих объектов, если важна скорость:
		Технически мы можем установить/получить [[Prototype]] в любое время. Но обычно мы устанавливаем прототип только раз во время создания объекта, а после не меняем: rabbit наследует от animal, и это не изменится.
		И JavaScript движки хорошо оптимизированы для этого. Изменение прототипа «на лету» с помощью Object.setPrototypeOf или obj.__proto__= – очень медленная операция, которая ломает внутренние оптимизации для операций доступа к свойствам объекта.
		
Важно:
	если мы попробуем хранить созданные пользователями ключи мы можем заметить интересный сбой: все ключи работают как ожидается, за исключением "__proto__".
		let key = prompt("What's the key?", "__proto__");
		obj[key] = "some value";

		alert(obj[key]); // [object Object], не "some value"!
	И это не должно удивлять нас. Свойство __proto__ особенное: оно должно быть либо объектом, либо null, а строка не может стать прототипом.

