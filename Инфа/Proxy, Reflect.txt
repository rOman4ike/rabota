let proxy = new Proxy(target, handler);

Proxy – это особый, «экзотический», объект, у него нет собственных свойств. С пустым handler он просто перенаправляет все операции на объект.
Прокси – это обёртка вокруг объекта, которая «по умолчанию» перенаправляет операции над ней на объект, но имеет возможность перехватывать их.

Для большинства действий с объектами в спецификации JavaScript есть так называемый «внутренний метод», который на самом низком уровне описывает, как его выполнять. Например, [[Get]] – внутренний метод для чтения свойства, [[Set]] – для записи свойства, и так далее. Эти методы используются только в спецификации, мы не можем обратиться напрямую к ним по имени.

Для каждого внутреннего метода в этой таблице указана ловушка, то есть имя метода, который мы можем добавить в параметр handler при создании new Proxy, чтобы перехватывать данную операцию:
Внутренний метод					Ловушка										Что вызывает
[[Get]]										get												чтение свойства
[[Set]]										set												запись свойства
[[HasProperty]]						has												оператор in
[[Delete]]								deleteProperty						оператор delete
[[Call]]									apply											вызов функции
[[Construct]]							construct									оператор new
[[GetPrototypeOf]]				getPrototypeOf						Object.getPrototypeOf
[[SetPrototypeOf]]				setPrototypeOf						Object.setPrototypeOf
[[IsExtensible]]					isExtensible							Object.isExtensible
[[PreventExtensions]]			preventExtensions					Object.preventExtensions
[[DefineOwnProperty]]			defineProperty						Object.defineProperty, Object.defineProperties
[[GetOwnProperty]]				getOwnPropertyDescriptor	Object.getOwnPropertyDescriptor, for..in, Object.keys/values/entries
[[OwnPropertyKeys]]				ownKeys										Object.getOwnPropertyNames, Object.getOwnPropertySymbols, for..in, Object.keys/values/entries


Важно!
Прокси следует использовать везде вместо target
Прокси должен заменить собой оригинальный объект повсюду. Никто не должен ссылаться на оригинальный объект после того, как он был проксирован. Иначе очень легко запутаться.

Существует широко распространённое соглашение о том, что свойства и методы, название которых начинается с символа подчёркивания _, следует считать внутренними. К ним не следует обращаться снаружи объекта.


Reflect API создано как дополнение к Proxy.
Reflect – встроенный объект, упрощающий создание прокси.
Нам следует использовать его, если нужно перенаправить вызов на оригинальный объект.
Ранее мы говорили о том, что внутренние методы, такие как [[Get]], [[Set]] и другие, существуют только в спецификации, что к ним нельзя обратиться напрямую.
Объект Reflect делает это возможным. Его методы – минимальные обёртки вокруг внутренних методов.

Вот примеры операций и вызовы Reflect, которые делают то же самое:
Операция						Вызов Reflect											Внутренний метод
obj[prop]						Reflect.get(obj, prop)						[[Get]]
obj[prop] = value		Reflect.set(obj, prop, value)			[[Set]]
delete obj[prop]		Reflect.deleteProperty(obj, prop)	[[Delete]]
new F(value)				Reflect.construct(F, value)				[[Construct]]

Для каждого внутреннего метода, перехватываемого Proxy, есть соответствующий метод в Reflect, который имеет такое же имя и те же аргументы, что и у ловушки Proxy.
В этом примере обе ловушки get и set прозрачно (как будто их нет) перенаправляют операции чтения и записи на объект, при этом выводя сообщение:
	let user = {
		name: "Вася",
	};

	user = new Proxy(user, {
		get(target, prop, receiver) {
		  alert(`GET ${prop}`);
		  return Reflect.get(target, prop, receiver); // (1)
		},
		set(target, prop, val, receiver) {
		  alert(`SET ${prop}=${val}`);
		  return Reflect.set(target, prop, val, receiver); // (2)
		}
	});

	let name = user.name; // выводит "GET name"
	user.name = "Петя"; // выводит "SET name=Петя"
	
	
Рассмотрим конкретный пример, демонстрирующий, чем лучше Reflect.get
	let user = {
		_name: "Гость",
		get name() {
		  return this._name;
		}
	};

	let userProxy = new Proxy(user, {
		get(target, prop, receiver) {
		  return target[prop]; // (*) target = user
		  // Ошибка правится так : return Reflect.get(target, prop, receiver)
		  // Receiver - ссылка на this
		  // Так как мы не можем передать receiver с помощью call/apply, мы используем Reflect
		}
	});

	let admin = {
		__proto__: userProxy,
		_name: "Админ"
	};

	// Ожидается: Админ
	alert(admin.name); // выводится Гость (?!?)
	
проблема в прокси, в строке (*).
	1. При чтении admin.name, так как в объекте admin нет свойства name, оно ищется в прототипе.
	2. Прототипом является прокси userProxy.
	3. При чтении из прокси свойства name срабатывает ловушка get и возвращает его из исходного объекта как target[prop] в строке (*).

	Вызов target[prop], если prop – это геттер, запускает его код в контексте this=target. Поэтому результатом является this._name из исходного объекта target, то есть из user.
	
Мы также можем оборачивать один и тот же объект много раз в разные прокси, добавляя ему различные аспекты функциональности.

	
Прокси имеют некоторые ограничения:
	1. Встроенные объекты используют так называемые «внутренние слоты», доступ к которым нельзя проксировать. Однако, ранее в этой главе был показан один способ, как обойти это ограничение.
	2. То же самое можно сказать и о приватных полях классов, так как они реализованы на основе слотов. То есть вызовы проксированных методов должны иметь оригинальный объект в качестве this, чтобы получить к ним доступ.
	3. Проверка объектов на строгое равенство === не может быть перехвачена.
	4. Производительность: конкретные показатели зависят от интерпретатора, но в целом получение свойства с помощью простейшего прокси занимает в несколько раз больше времени. В реальности это имеет значение только для некоторых «особо нагруженных» объектов.

