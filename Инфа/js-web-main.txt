Документ:
  Браузерное окружение, спецификации:
    'Окружение' - среда JavaScript, каждая из которых предоставляет свои объекты и дополнительные функции, в дополнение базовым языковым (в браузере, на веб-сервере или в какой-то другой среде)

    DOM (Document Object Model):
      'DOM' – это объектная модель документа, которую браузер создает в памяти компьютера на основании HTML-кода, полученного им от сервера.
      'Объект document' – основная «входная точка». С его помощью мы можем что-то создавать или менять на странице.

    BOM (Browser Object Model):
      'BOM' - объекты, через которые JavaScript взаимодействует с браузером
      'Объект window' - представляет собой браузер

  DOM-дерево:
    В соответствии с DOM, каждый HTML-тег является объектом.

    Пример DOM:
      'Узел-элемент' - теги HTML: <html> – это корневой узел, <head> и <body> его дочерние узлы и т.д.
      'Текстовый узел' - текст внутри элементов, обозначенные как #text: в теге <p> есть текстовый узел "О лосях".
      'Узел-комментарий': <!-- -->

      Все, что есть в HTML, даже комментарии, является частью DOM.

    Автоисправление:
      Если браузер сталкивается с некорректно написанным HTML-кодом, он автоматически корректирует его при построении DOM.
      Пример:
        1. <p>Привет - браузер автоматически его закроет
        2. Таблица всегда содержит тег <tbody>
        3. В начале документа всегда должен быть тег <html>

    Взаимодействие с консолью:
      Последний элемент, выбранный во вкладке Elements в инструментах разработчика, доступен в консоли как $0; предыдущий, выбранный до него, как $1 и т.д.

  Навигация по DOM-элементам:
    В DOM значение null значит «не существует» или «нет такого узла».

    'Дочерние узлы (или дети)' – элементы, которые лежат непосредственно внутри данного. Например, <head> и <body> являются детьми элемента <html>.
    'Потомки' - все элементы, которые лежат внутри данного, включая детей, их детей и т.д.
    'Соседи' - это узлы, у которых один и тот же родитель.
    'Предки элемента' - родитель, родитель родителя, его родитель и так далее.

    'ВАЖНО!'
      DOM-коллекции, и даже более - все навигационные свойства, перечисленные в этой главе, доступны только для чтения.
      Мы не можем заменить один дочерний узел на другой, просто написав childNodes[i] = ...

    'ВАЖНО!'
      Почти все DOM-коллекции, за небольшим исключением, живые.
      Если мы сохраним ссылку на elem.childNodes и добавим/удалим узлы в DOM, то они появятся в сохранённой коллекции автоматически.

      'ВАЖНО!'
        Зачем нужен parentElement? Разве может родитель быть не элементом?
          alert( document.documentElement.parentNode ); // выведет document
          alert( document.documentElement.parentElement ); // выведет null
        Причина в том, что родителем корневого узла document.documentElement (<html>) является document.
        Но document - это не узел-элемент, так что parentNode вернёт его, а parentElement нет.

  Поиск: getElement*, querySelector*:
    Есть глобальная переменная с именем, указанным в id:
      <div id="elem">
        <div id="elem-content">Элемент</div>
      </div>

      <script>
        elem.style.background = 'red';
        window['elem-content'].style.color = 'blue';
      </script>

    'ВАЖНО!'
      Пожалуйста, не используйте такие глобальные переменные для доступа к элементам

  Свойства узлов: тип, тег и содержимое:
    У разных DOM-узлов могут быть разные свойства. Например, у узла, соответствующего тегу <input> – свойства, связанные с полем ввода и т.д.

  Атрибуты и свойства:
    Ранее мы уже видели встроенные DOM-свойства. Их много.
    DOM-узлы – это обычные объекты JavaScript. Мы можем их изменять.

    Когда у элемента есть id или другой стандартный атрибут, создаётся соответствующее свойство.
    Но этого не происходит, если атрибут нестандартный.
      <body id="test" something="non-standard">
        <script>
          alert(document.body.id); // test
          alert(document.body.something); // undefined
        </script>
      </body>

    У HTML-атрибутов есть следующие особенности:
      1. Их имена регистронезависимы (id то же самое, что и ID).
      2. Их значения почти всегда являются строками (К примеру input.checked вернет true/false)

    Когда стандартный атрибут изменяется, соответствующее свойство автоматически обновляется. Это работает и в обратную сторону (за некоторыми исключениями).
      <script>
        let input = document.querySelector('input');
        input.setAttribute('id', 'id');
        alert(input.id); // id (обновлено)
      </script>
    Но есть и исключения, например, input.value синхронизируется только в одну сторону – атрибут → значение

Введение в события:
  Введение в браузерные события:
    'Событие' - это сигнал от браузера о том, что что-то произошло. Все DOM-узлы подают такие сигналы (хотя события бывают и не только в DOM).
    Событию можно назначить 'обработчик', то есть функцию, которая сработает, как только событие произошло.

    Есть несколько способов назначить событию обработчик:
      1. Использование атрибута HTML
        <button onclick="myFunction(this)">Нажми меня</button> <!-- this вернет текущий узел-элемент -->
      2. Можно назначать обработчик, используя свойство DOM-элемента on<событие>.
        elem.onclick = function() { alert('Спасибо'); };
        elem.addEventListener('click', function(this) { alert('Спасибо'); })
        <!-- Лучше пользоваться addEventListener, т.к позволяет повесить несколько обработчиков на одно событие -->
        <!-- Существуют события, которые нельзя назначить через DOM-свойство, но можно через addEventListener. Например DOMContentLoaded -->

    Когда происходит событие, браузер создаёт 'объект события', записывает в него детали и передаёт его в качестве аргумента функции-обработчику.
    elem.onclick = function(event) { console.log(event) };

  Всплытие и погружение:
    Стандарт DOM Events описывает 3 фазы прохода события:
      1. Фаза погружения (capturing phase) – событие сначала идёт сверху вниз.
      2. Фаза цели (target phase) – событие достигло целевого(исходного) элемента.
      3. Фаза всплытия (bubbling stage) – событие начинает всплывать.

    'Всплытие' - процесс, в котором событие, произошедшее на каком-либо вложенном элементе, всплывает вверх по DOM-дереву и вызывает такие же события на всех родительских элементах

    'ВАЖНО!'
      Почти все события всплывают.
      Например, событие focus не всплывает. В дальнейшем мы увидим и другие примеры.
      Однако, стоит понимать, что это скорее исключение, чем правило, всё-таки большинство событий всплывают.

    'ВАЖНО!'
      Не прекращайте всплытие без необходимости!

    'Целевой элемент' - самый глубокий элемент, который вызывает событие, и он доступен через event.target.
    Отличия от this (=event.currentTarget):
      1. event.target – это «целевой» элемент, на котором произошло событие, в процессе всплытия он неизменен.
      2. this – это «текущий» элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик.

    'Погружение' - ???

  Делегирование событий:
    'Делегирование' - идея в том, что если у нас есть много элементов, события на которых нужно обрабатывать похожим образом, то вместо того,
    чтобы назначать обработчик каждому, мы ставим один обработчик на их общего предка.

  Действия браузера по умолчанию:
    Многие события автоматически влекут за собой действие браузера.
    Например:
      1. Клик по ссылке инициирует переход на новый URL.
      2. Нажатие на кнопку «отправить» в форме – отсылку её на сервер.

    Есть два способа отменить действие браузера:
      1. Основной способ – это воспользоваться объектом event. Для отмены действия браузера существует стандартный метод event.preventDefault().
      2. Если же обработчик назначен через on<событие> (не через addEventListener), то также можно вернуть false из обработчика.

    'ВАЖНО!'
      Возвращать true не нужно
      Обычно значение, которое возвращает обработчик события, игнорируется.
      Единственное исключение – это return false

    'ВАЖНО!'
      Некоторые события естественным образом вытекают друг из друга. Если мы отменим первое событие, то последующие не возникнут.
      Например, событие mousedown для поля <input> приводит к фокусировке на нём и запускает событие focus. Если мы отменим событие mousedown, то фокусирования не произойдёт.
        <input onmousedown="return false" onfocus="this.value=''" value="Кликни меня">

  Генерация пользовательских событий:
    Это класс Event, который пока нихуя не понятен и мне сейчас впадлу им заниматься(Скорее всего такаяже залупа как и Symbol())

Интерфейсные события:
  Основы событий мыши:
    Сразу заметим: эти события бывают не только из-за мыши, но и эмулируются на других устройствах, в частности, на мобильных, для совместимости.

    В случае, когда одно действие инициирует несколько событий, порядок их выполнения фиксирован.
    То есть обработчики событий вызываются в следующем порядке: mousedown → mouseup → click.

  Движение мыши: mouseover/out, mouseenter/leave:
    Событие mousemove происходит при движении мыши. Однако, это не означает, что указанное событие генерируется при прохождении каждого пикселя.
    Браузер периодически проверяет позицию курсора и, заметив изменения, генерирует события mousemove.

  Drag'n'Drop с событиями мыши:
    Надо будет, разберу, а так пока похуй

  Клавиатура: keydown и keyup:
    Прежде чем перейти к клавиатуре, обратите внимание, что на современных устройствах есть и другие способы «ввести что-то».
    Например, распознавание речи (это особенно актуально на мобильных устройствах) или Копировать/Вставить с помощью мыши.

    Поэтому, если мы хотим корректно отслеживать ввод в поле <input>, то одних клавиатурных событий недостаточно.
    Существует специальное событие 'input', чтобы отслеживать любые изменения в поле <input>.

    События клавиатуры же должны использоваться, если мы хотим обрабатывать взаимодействие пользователя именно с клавиатурой (в том числе виртуальной).
    К примеру, если нам нужно реагировать на стрелочные клавиши Up и Down или горячие клавиши (включая комбинации клавиш).

    При долгом нажатии клавиши возникает автоповтор: keydown срабатывает снова и снова, и когда клавишу отпускают, то отрабатывает keyup.

    Предотвращение стандартного действия с помощью event.preventDefault() работает практически во всех сценариях, кроме тех,
    которые происходят на уровне операционной системы. Например, комбинация Alt+F4 инициирует закрытие браузера в Windows, что бы мы ни делали в JavaScript.

  События указателя:
    'События указателя (Pointer events)' – это современный способ обработки ввода с помощью различных указывающих устройств, таких как мышь, перо/стилус, сенсорный экран и так далее.
    Если вы не разрабатываете под старые браузеры, такие как Internet Explorer 10, Safari 12, или более ранние версии - используем pointer events

    События указателя содержат те же свойства, что и события мыши, например clientX/Y, target и т.п., и несколько дополнительных:
      1. pointerId – уникальный идентификатор указателя, вызвавшего событие.
        Идентификатор генерируется браузером. Это свойство позволяет обрабатывать несколько указателей, например сенсорный экран со стилусом и мульти-тач (увидим примеры ниже).
      2. pointerType – тип указывающего устройства. Должен быть строкой с одним из значений: «mouse», «pen» или «touch».
        Мы можем использовать это свойство, чтобы определять разное поведение для разных типов указателей.
      3. isPrimary – равно true для основного указателя (первый палец в мульти-тач).

  Прокрутка:
    Событие прокрутки scroll позволяет реагировать на прокрутку страницы или элемента.
    Как можно сделать что-то непрокручиваемым?
    Нельзя предотвратить прокрутку, используя event.preventDefault() в обработчике onscroll, потому что он срабатывает после того, как прокрутка уже произошла.
    Но можно предотвратить прокрутку, используя event.preventDefault() на событии, которое вызывает прокрутку, например, на событии keydown для клавиш pageUp и pageDown.

    Способов инициировать прокрутку много, поэтому более надёжный способ – использовать CSS, свойство overflow.

Формы, элементы управления:
Свойства и методы формы:

Фокусировка: focus/blur:
	Элемент получает фокус, когда пользователь кликает по нему или использует клавишу Tab.
  Также существует HTML-атрибут autofocus, который устанавливает фокус на элемент, когда страница загружается.

  Фокусировка обычно означает: «приготовься к вводу данных на этом элементе», это хороший момент, чтобы инициализовать или загрузить что-нибудь.
	Потеря фокуса обычно означает «данные введены», и мы можем выполнить проверку введённых данных или даже отправить эти данные на сервер и так далее.

  Отметим, что мы не можем «отменить потерю фокуса», вызвав event.preventDefault() в обработчике onblur потому, что onblur срабатывает после потери фокуса элементом.
  'ВАЖНО!'
    Потеря фокуса может произойти по множеству причин.
    Одна из них – когда посетитель кликает куда-то ещё. Но и JavaScript может быть причиной, например:
      1. alert переводит фокус на себя – элемент теряет фокус (событие blur), а когда alert закрывается – элемент получает фокус обратно (событие focus).
      2. Если элемент удалить из DOM, фокус также будет потерян. Если элемент добавить обратно, то фокус не вернётся.

  Многие элементы по умолчанию не поддерживают фокусировку - Это можно изменить HTML-атрибутом 'tabindex'.

События: change, input, cut, copy, paste:

Отправка формы: событие и метод submit:

Загрузка документа и ресурсов:
  У жизненного цикла HTML-страницы есть три важных события:
		1. DOMContentLoaded – браузер полностью загрузил HTML, было построено DOM-дерево, но внешние ресурсы, такие как картинки <img> и стили, могут быть ещё не загружены.
		2. load – браузер загрузил HTML и внешние ресурсы (картинки, стили и т.д.).
		3. beforeunload/unload – пользователь покидает страницу.
	Каждое из этих событий может быть полезно:
		1. Событие DOMContentLoaded – DOM готов, так что обработчик может искать DOM-узлы и инициализировать интерфейс.
		2. Событие load – внешние ресурсы были загружены, стили применены, размеры картинок известны и т.д.
		3. Событие beforeunload – пользователь покидает страницу. Мы можем проверить, сохранил ли он изменения и спросить, на самом ли деле он хочет уйти.
		4. unload – пользователь почти ушёл, но мы всё ещё можем запустить некоторые операции, например, отправить статистику.
	'document.addEventListener("DOMContentLoaded", ready);'

  Когда браузер обрабатывает HTML-документ и встречает тег <script>, он должен выполнить его перед тем, как продолжить строить DOM.
  Скрипты с атрибутом async, который мы рассмотрим немного позже, не блокируют DOMContentLoaded.

  window.onunload - Обычно здесь отсылают статистику.

Скрипты: async, defer:
  В современных сайтах скрипты обычно «тяжелее», чем HTML: они весят больше, дольше обрабатываются.
	Когда браузер загружает HTML и доходит до тега <script>...</script>, он не может продолжать строить DOM.

  Это ведёт к двум важным проблемам:
    1. Скрипты не видят DOM-элементы ниже себя, поэтому к ним нельзя добавить обработчики и т.д.
    2. Если вверху страницы объёмный скрипт, он «блокирует» страницу. Пользователи не видят содержимое страницы, пока он не загрузится и не запустится:

  Атрибут defer сообщает браузеру, что он должен продолжать обрабатывать страницу и загружать скрипт в фоновом режиме
  Отложенные с помощью defer скрипты сохраняют порядок относительно друг друга, как и обычные скрипты.

  'ВАЖНО!'
    Атрибут defer будет проигнорирован, если в теге <script> нет src.
    Как и в случае с defer, атрибут async будет проигнорирован, если в теге <script> нет src.

  Атрибут async означает, что скрипт абсолютно независим
    Асинхронные скрипты очень полезны для добавления на страницу сторонних скриптов: счётчиков, рекламы и т.д.
    Они не зависят от наших скриптов, и мы тоже не должны ждать их

Загрузка ресурсов: onload и onerror:
  Браузер позволяет отслеживать загрузку сторонних ресурсов: скриптов, ифреймов, изображений и др.
	Для этого существуют два события:
		1. 'load' – успешная загрузка. Срабатывает после того, как скрипт был загружен и выполнен (Может быть полезен для динамических скриптов).
		2. 'error' – во время загрузки произошла ошибка. Ошибки, которые возникают во время загрузки скрипта, могут быть отслежены с помощью события

  Есть правило: скрипты с одного сайта не могут получить доступ к содержимому другого сайта.
  Например, скрипт с https://facebook.com не может прочитать почту пользователя на https://gmail.com.
  Если мы используем скрипт с другого домена, и в нем имеется ошибка, мы не сможем узнать детали этой ошибки.

  Чтобы разрешить кросс-доменный доступ, нам нужно поставить тегу <script> атрибут crossorigin, и, кроме того, удалённый сервер должен поставить специальные заголовки.
  Существует три уровня кросс-доменного доступа:
    1. Атрибут crossorigin отсутствует – доступ запрещён.
    2. crossorigin="anonymous" – доступ разрешён, если сервер отвечает с заголовком Access-Control-Allow-Origin со значениями * или наш домен. Браузер не отправляет авторизационную информацию и куки на удалённый сервер.
    3. crossorigin="use-credentials" – доступ разрешён, если сервер отвечает с заголовками Access-Control-Allow-Origin со значением наш домен и Access-Control-Allow-Credentials: true. Браузер отправляет авторизационную информацию и куки на удалённый сервер.
  Теперь при условии, что сервер предоставил заголовок Access-Control-Allow-Origin, всё хорошо. У нас есть полный отчёт по ошибкам.

Разное:
  'MutationObserver' – это встроенный объект, наблюдающий за DOM-элементом и запускающий колбэк в случае изменений.

Selection и Range:
  В основе выделения лежит 'Range' – диапазон. Он представляет собой пару «граничных точек»: начало и конец диапазона.

  Range это общий объект для управления диапазонами выделения. Мы можем создавать и передавать подобные объекты.
  Сами по себе они ничего визуально не выделяют.
  Выделение в документе представлено объектом 'Selection', который может быть получен как 'window.getSelection()' или 'document.getSelection()'.

Событийный цикл: микрозадачи и макрозадачи:
	Поток выполнения в браузере, равно как и в Node.js, основан на 'событийном цикле'.
	Понимание работы событийного цикла важно для оптимизаций, иногда для правильной архитектуры.
  Браузер отрисовывает содержимое страницы после того, как заканчивается выполнение текущего кода. Не имеет значения, насколько долго выполняется задача. Изменения в DOM отображаются только после её завершения.

  Может так случиться, что задача поступает, когда движок занят чем-то другим, тогда она ставится в очередь.
  Очередь, которую формируют такие задачи, называют 'очередью макрозадач' (macrotask queue, термин v8).

  Задачи из очереди исполняются по правилу «первым пришёл – первым ушёл».
		Отметим две детали:
			1. Рендеринг (отрисовка страницы) никогда не происходит во время выполнения задачи движком. Не имеет значения, сколь долго выполняется задача.
				Изменения в DOM отрисовываются только после того, как задача выполнена.
			2. Если задача выполняется очень долго, то браузер не может выполнять другие задачи, обрабатывать пользовательские события, поэтому спустя некоторое время браузер предлагает
				«убить» долго выполняющуюся задачу. Такое возможно, когда в скрипте много сложных вычислений или ошибка, ведущая к бесконечному циклу.

  'Макрозадачи' - это setTimeout, setInterval и setImmediate, а 'микрозадачи' - это Promise, MutationObserver и process.nextTick.
  Микрозадачи приходят только из кода. Обычно они создаются промисами: выполнение обработчика .then/catch/finally становится 'микрозадачей'.
  Сразу после каждой макрозадачи движок исполняет все задачи из очереди микрозадач перед тем, как выполнить следующую макрозадачу или отобразить изменения на странице, или сделать что-то ещё.

  Ну и евент луп не относится к javascript, а определяется окружением, в нашем случае - браузером.

Методы:
  <html> = document.documentElement
  <body> = document.body
  <head> = document.head

  # Метод для всех узлов = Метод для узлов-элементов
    childNodes = children
    firstChild = firstElementChild
    ??? = previousElementSibling
    parentNode = parentElement

  # Получение элементов
    'querySelector' - элемент по селектору
    'closest' - родитель по селектору
    'contains' - содержит ли один элемент внутри себя другой
      let parent = document.querySelector('#parent');
      let child = document.querySelector('#child');
      let contains = parent.contains(child);
      console.log(contains); // true

  # Вставка элемента
    'append'/'prepend' - Вставка элемента в конец/начало элемента
    'insertAdjacentElement' - вставка элементов
    'insertAdjacentHTML' - вставка HTML-кода

  # Получение родственников
    children - все потомки элемента
    firstElementChild - первый потомок
    parentElement - получение родителя

  # Создание элементов
    createElement - создание элемента
    cloneNode - клонирование узла

  # Удаление элементов
    remove - удаление
    removeChild - удаление узлов

  # Атрибуты
    getAttribute/setAttribute/removeAttribute/hasAttribute
    dataset

  # CSS-классы/стили
    elem.className - получить атрибут class (строка)
    elem.style
    classList - объект с классами
    classList.add
    classList.remove
    classList.toggle

  # Размеры
    offsetParent - содержит ближайшего родителя, относительно которого происходит позиционирование элемента.
    offsetWidth/Height - содержат полный размер элемента (включая border и scrollbar)
    offsetLeft/offsetTop содержат координаты x/y относительно верхнего левого угла offsetParent.

    clientLeft/clientTop -содержит ширину левой/правой границы (значение border-left + полоса прокрутки слева)
    clientWidth/clientHeight - содержит высоту элемента внутри границ вместе с padding, но без border и прокрутки.

  # Размеры и прокрутка окна
    documentElement.clientHeight/clientWidth - высота/ширина окна
    window.innerWidth/window.innerHeight - высота/ширина браузера
    elem.scrollLeft/scrollTop - получение текущей прокрутки

  # События
    addEventListener/removeEventListener

  # Объект Event
    event.preventDefault()
    event.stopPropagation()/event.stopImmediatePropagation()
    event.type - тип события
    event.target - элемент, на котором событие сработало (this - элемент, к которому привязано событие)
    event.button - какую кнопку нажали
    event.key/event.code
    event.shiftKey, event.altKey, event.metaKey
    event.repeat - true, если событие вызвано автоповтором

События:
  'click'
  'mouseover'
  'focus/blur'
  'keydown/keyup'
  'cut/copy/paste'
  'change/input'
  'submit'
  'resize'
  'load/readystatechange/DOMContentLoaded'
  'storage'

  'ВАЖНО!'
    Не забывайте про мобильные устройства
    Комбинации клавиш хороши в качестве дополнения к рабочему процессу. Так что, если посетитель использует клавиатуру – они работают.
    Но если на их устройстве его нет – тогда должен быть способ жить без клавиш-модификаторов.

    Событие указателя					|			Аналогичное событие мыши
		--------------------------------------------------------
		pointerdown	        			|			mousedown
		pointerup	          			|			mouseup
		pointermove	        			|			mousemove
		pointerover	        			|			mouseover
		pointerout	        			|			mouseout
		pointerenter	      			|			mouseenter
		pointerleave	      			|			mouseleave
		pointercancel	      			|			-
		gotpointercapture	  			|			-
		lostpointercapture				|			-

  Событие 'focus' вызывается в момент фокусировки, а 'blur' – когда элемент теряет фокус.
  Методы 'elem.focus()' и 'elem.blur()' устанавливают/снимают фокус.

  Это можно изменить HTML-атрибутом 'tabindex'.
  Есть два специальных значения:
  1. tabindex="0" ставит элемент в один ряд с элементами без tabindex. То есть, при переключении такие элементы будут после элементов с tabindex ≥ 1.
    Обычно используется, чтобы включить фокусировку на элементе, но не менять порядок переключения.
    Чтобы элемент мог участвовать в форме наравне с обычными <input>.
    Порядок такой: 1 - 2 - 0
  2. tabindex="-1" позволяет фокусироваться на элементе только программно. Клавиша Tab проигнорирует такой элемент, но метод elem.focus() будет действовать.

  Событие 'change' срабатывает по окончании изменения элемента.
  Для текстовых <input> это означает, что событие происходит при потере фокуса.
  Для других элементов: select, input type=checkbox/radio событие запускается сразу после изменения значения

  Событие 'input' срабатывает каждый раз при изменении значения.

  При отправке формы срабатывает событие 'submit', оно обычно используется для проверки (валидации) формы перед её отправкой на сервер
  Метод 'form.submit()' позволяет инициировать отправку формы из JavaScript.
  Обработчик может проверить данные, и если есть ошибки, показать их и вызвать event.preventDefault(), тогда форма не будет отправлена на сервер.
  'ВАЖНО!'
    Взаимосвязь между submit и click
    При отправке формы по нажатию Enter в текстовом поле, генерируется событие click на кнопке <input type="submit">.
    Это довольно забавно, учитывая что никакого клика не было.


ПОПОЗЖЕ:
  'ВАЖНО!'
    Псевдоклассы тоже работают
    document.querySelectorAll(':hover')

  'ВАЖНО!'
    Только document.getElementById, а не anyElem.getElementById
    Метод getElementById можно вызвать только для объекта document.

  'ВАЖНО!'
    Все методы "getElementsBy*" возвращают живую коллекцию. Такие коллекции всегда отражают текущее состояние документа и автоматически обновляются при его изменении.
		Напротив, querySelectorAll возвращает статическую коллекцию. Это похоже на фиксированный массив элементов.

  'ВАЖНО!'
    Свойство «nodeType»:
		В современных скриптах, чтобы узнать тип узла, мы можем использовать метод instanceof и другие способы проверить класс, но иногда nodeType проще использовать.
		Мы не можем изменить значение nodeType, только прочитать его.

  'ВАЖНО!'
    Скрипты не выполнятся
    Если innerHTML вставляет в документ тег <script> – он становится частью HTML, но не запускается.

  'ВАЖНО!'
    Будьте внимательны: «innerHTML+=» осуществляет перезапись
      chatDiv.innerHTML += "Как дела?";
    Технически эти две строки делают одно и то же:
      elem.innerHTML += "...";
      // это более короткая запись для:
      elem.innerHTML = elem.innerHTML + "..."
    'Так как содержимое «обнуляется» и переписывается заново, все изображения и другие ресурсы будут перезагружены.'

  'ВАЖНО!'
    Использование outerHTML не изменяет DOM-элемент, а удаляет его из внешнего контекста и вставляет вместо него новый HTML-код.

  'ВАЖНО!'
    Объект-обработчик: handleEvent:
      Мы можем назначить обработчиком не только функцию, но и объект при помощи addEventListener.
      В этом случае, когда происходит событие, вызывается метод объекта handleEvent.
      К примеру:
        <button id="elem">Нажми меня</button>
        <script>
          elem.addEventListener('click', {
            handleEvent(event) {
              alert(event.type + " на " + event.currentTarget);
            }
          });
        </script>

  'ВАЖНО!'
    Чтобы убрать обработчик removeEventListener, нужна та же фаза
    Если мы добавили обработчик вот так addEventListener(..., true), то мы должны передать то же значение аргумента
    capture в removeEventListener(..., true), когда снимаем обработчик.

  'ВАЖНО!'
    Если был mouseover, то будет и mouseout

  'ВАЖНО!'
		Важная особенность события mouseout – оно генерируется в том числе, когда указатель переходит с элемента на его потомка.
		То есть, визуально указатель всё ещё на элементе, но мы получим mouseout!
		Событие mouseover, происходящее на потомке, всплывает. Поэтому если на родительском элементе есть такой обработчик, то оно его вызовет.

    События mouseenter/mouseleave похожи на mouseover/mouseout. Они тоже генерируются, когда курсор мыши переходит на элемент или покидает его.
		Но есть и пара важных отличий:
			1. Переходы внутри элемента, на его потомки и с них, не считаются.
			2. События mouseenter/mouseleave не всплывают.

  'ВАЖНО!'
    Замена mouse<событий> на pointer<события> в коде
    Мы можем заменить события mouse... на аналогичные pointer... в коде и быть уверенными, что с мышью по-прежнему всё будет работать нормально.
    При этом поддержка сенсорных устройств «волшебным» образом улучшится. Хотя, возможно, кое-где понадобится добавить touch-action: none в CSS.

  'ВАЖНО!'
    События focus и blur не всплывают.
    Решение: события 'focusin' и 'focusout' – такие же, как и focus/blur, но они всплывают.