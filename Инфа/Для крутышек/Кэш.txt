Статьи:
  https://medium.com/@codebyamir/a-web-developers-guide-to-browser-caching-cc41f3b73e7c
  https://blog.bitsrc.io/web-caching-best-practices-ae9580ceb4b3
  https://blog.bitsrc.io/understanding-service-workers-and-caching-strategies-a6c1e1cbde03
  https://www.baeldung.com/cs/caching-cold-cache-vs-warm-cache
  https://blog.skillfactory.ru/glossary/cache/
  https://www.designgurus.io/blog/cache-invalidation-strategies
  https://www.geeksforgeeks.org/cache-invalidation-and-the-methods-to-invalidate-cache/
  https://www.imperva.com/learn/performance/browser-caching/

  Что не прочитал (практика):
  Сначала читаем эти:
    https://www.namehero.com/blog/should-you-warm-your-cache-if-so-how-often/
    https://medium.com/nerd-for-tech/swr-frontend-data-fetching-and-caching-ca0313239d6f
    https://vuestorefront.io/blog/how-to-deal-with-caching-and-dynamic-content
    https://calendar.perfplanet.com/2016/a-tale-of-four-caches/ (необязательно)
  Потом эти:
    https://www.google.com/search?q=js+optimize+cache&newwindow=1&sca_esv=559287649&ei=A4LlZK-RNdiCxc8P0dCKkAk&oq=js+optimize+cac&gs_lp=Egxnd3Mtd2l6LXNlcnAiD2pzIG9wdGltaXplIGNhYyoCCAAyBRAhGKABMgUQIRigATIFECEYoAFI2jlQ2QdYwDBwAXgBkAEAmAGWAaAB-w2qAQQwLjE1uAEDyAEA-AEBwgIKEAAYRxjWBBiwA8ICBhAAGBYYHsICCBAAGBYYHhgPwgIFEAAYgATCAgcQABiKBRhDwgINEAAYigUYsQMYgwEYQ8ICCxAAGIAEGLEDGIMBwgIIEAAYgAQYsQPiAwQYACBBiAYBkAYI&sclient=gws-wiz-serp
    https://www.webperf.tips/tip/cached-js-misconceptions/
    https://github.com/sq/JSIL/wiki/Optimizing-dynamic-JavaScript-with-inline-caches
    https://blog.logrocket.com/frontend-caching-in-vue-with-workbox-service-workers/
    https://vuestorefront.io/blog/how-to-deal-with-caching-and-dynamic-content
    https://www.vuemastery.com/blog/data-fetching-and-caching-with-swr-and-vuejs/
    https://vueschool.io/articles/vuejs-tutorials/vue-js-performance-mastering-cache/
    https://blog.openreplay.com/the-cache-api-in-javascript-and-how-to-use-it/

Определения:
  'Кэш' - это просто область хранения, в которой данные хранятся в течение короткого времени.
  'Кэширование' - это процесс, при котором данные сохраняются в кэш.
  'Браузерное кэширование' - это процесс временного хранения ресурсов в веб-браузерах.
  'Кэш браузера' — это обычно папка в каталоге, где находятся его файлы.
  'Cache invalidation' - процесс обновления или удаления старых данных в кэше, чтобы обеспечить актуальность данных.

Как устроен кэш:
  Это перечень записей с информацией. Данные в них — копии данных, которые есть в «обычной» памяти или на серверах.
  У каждой записи есть свой идентификатор, или тег, — он показывает, в каком участке «обычной» памяти расположена эта же информация.

Типы кэширования:
  1. Server-side Caching
    Временно сохраняет веб-файлы и данные на отдельном сервере для последующего использования, эффективно снижая нагрузку на сервер
      и уменьшая время ожидания.
    Примечание - Серверный кэш является промежуточным звеном между браузером и исходным сервером.
    Основной проблемой кэширования на стороне сервера является задержка. Задержка может быть определена как общее
      время прохождения пакета данных от источника до места назначения.
    Еще одна проблема - Сетевые запросы по-прежнему необходимы
  2. Client-side Caching
    Часто называемое браузерным кэшированием, временно сохраняет копию веб-страницы в памяти браузера (в папке, создаваемой браузером).
    Одним из недостатков кэширования на стороне клиента является то, что оно зависит от браузера, и если вы используете
      несколько браузеров, то у вас будут разные кэш-файлы одной и той же веб-страницы.
    Другим недостатком клиентского кэширования является то, что оно более сложное, чем серверное.

  Server-side vs Client-side caching:
    Кэширование на стороне сервера в сравнении с кэшированием на стороне клиента
    Выбор типа кэширования значительно улучшает общее впечатление от сайта WordPress и удобство его использования.
    Поэтому всегда лучше заранее понять, какой тип кэширования подходит именно вашему сайту.

    Серверное кэширование является наилучшим выбором для сайтов со статическим содержимым и недолговечным кэшем, так как оно
      значительно сокращает количество операций на сервере - без необходимости перестраивать все содержимое по каждому запросу пользователя.
    С другой стороны, высокодинамичный серверный кэш все же возможен при использовании таких передовых технологий,
      как Edge Side Includes (ESI) или Ajax (Asynchronous JavaScript and XML).

Типы веб-кэша:
  1. Page Cache (Site Cache)
  2. Server Cache
  3. Proxy Cache
  4. Browser Cache
  5. Object Cache

Плюсы кэширования в браузере:
  1. Если мы кэшируем содержимое в браузере, то получение данных происходит мгновенно.
    Однако пользователь может испытывать задержку при первоначальной загрузке страницы, пока кэш не будет заполнен.
  2. Кэширование позволяет повысить доступность сайта на разных уровнях.
    Когда мы кэшируем содержимое на уровне браузера, это позволяет избежать проблем с навигацией в условиях плохой сети.
  3. Большие шансы на масштабирование
    Поскольку фронтальное кэширование уменьшает количество запросов, отправляемых на сервер, необходимость в очень мощной машине отпадает.
    Например, если на сайте имеется много изображений высокого разрешения, то получение этих файлов всегда приводит к большому трафику на сервере.
    Однако если они будут кэшироваться, то большая часть трафика может быть исключена.

Недостатки кэширования в браузере:
  1. Иногда новая информация на сайте может не обновляться в кэше.
  2. Реализация кэширования может потребовать соблюдения многих требований, таких как требования к данным,
    обслуживанию, серверам и производительности.
  3. Неправильная настройка кэширования может привести к тому, что браузер будет получать устаревшее содержимое, что
    негативно скажется на работе пользователя.

Заголовки HTTP:
  'Etag':
    'ETag (или Entity Tag)' - это строка, которая служит маркером проверки кэша. Обычно это хэш содержимого файла.
  'Cache-Control':
    Содержит ряд директив, которые мы можем установить для управления поведением кэша, сроком его действия и проверкой.
    Их также можно комбинировать.
    Поведение кэша:
      Cache-Control: public - означает, что ресурс может быть кэширован любым кэшем (браузером, CDN и т.д.)
      Cache-Control: private - означает, что ресурс может быть кэширован только браузером
      Cache-Control: no-store - означает, что браузер должен всегда запрашивать ресурс с сервера
      Cache-Control: no-cache - указывает браузеру на то, что он должен кэшировать файл, но не использовать его до тех пор,
        пока он не проверит на сервере, что у нас есть последняя версия. Эта проверка выполняется с помощью заголовка ETag(Сервер) и If-None-Match(Клиент).
    Срок действия:
      Cache-Control: max-age=60
      Здесь указывается время в секундах, в течение которого ресурс должен быть кэширован.
      Если он уже кэширован, он должен быть проверен на сервере перед использованием. Если сервер подтверждает,
        что кэшированная копия все еще действительна, она может быть использована вместо повторной загрузки ресурса.
    Валидация:
      Cache-Control: must-revalidate
      Это указывает кэшу, что он должен проверять статус устаревшего ресурса перед его использованием,
        а просроченные ресурсы не должны использоваться.
  'Expires':
    'Браузер будет игнорировать это поле, если в Cache-Control присутствует директива max-age'
    Относится к старым версиям HTTP 1.0
    В этом поле заголовка указывается дата истечения срока действия, после которой актив считается недействительным.
  'Last-Modified':
    Также относится к временам HTTP 1.0
    Данное поле содержит дату и время последнего изменения ресурса.

Проблемы кэширования:
  Мы также хотим, чтобы пользователи видели последнюю версию нашей страницы, когда мы делаем обновления.
  Мы не можем ожидать, что при каждом посещении сайта они будут делать жесткое обновление (Ctrl-F5) или регулярно очищать свой кэш.

  Подобные проблемы с кэшированием часто становятся источником разочарования как для разработчика, так и для конечного пользователя.
  Пользователь может увидеть неработающую страницу или кнопку, которая ведет себя странно из-за устаревшей таблицы стилей или кода JavaScript.

  Решения проблемы:
    'Мы можем дать браузеру команду обойти кэш, просто изменив имя файла. Для браузера это будет совершенно новый ресурс, поэтому он получит его с сервера.'
    1. Cache Busting
      'Cache Busting' - это когда мы аннулируем кэшированный файл и заставляем браузер получить его с сервера.
      Мы можем дать браузеру команду обойти кэш, просто изменив имя файла.
      Для браузера это будет совершенно новый ресурс, поэтому он получит его с сервера.

      Обход кэша также позволяет нам сохранять длительные значения max-age для ресурсов, которые могут часто меняться.
      Google рекомендует устанавливать значение max-age равным 1 году (источник).

    2. Versioning
      Мы можем добавить номер версии к имени файла:
      assets/js/app-v2.min.js

    3. Fingerprinting
      Мы можем добавить fingerprint, основанный на содержимом файла:
      assets/js/app-d41d8cd98f00b204e9800998ecf8427e.min.js

    3. Append Query String
      Мы можем добавить строку запроса в конец имени файла:
      assets/js/app.min.js?version=2
      Известно, что при использовании строки запроса возникают проблемы с прокси-серверами, поэтому использовать этот метод не рекомендуется.

  Best Practice:
    ДА:
      1. Используйте заголовки Cache-Control и ETag для управления поведением кэша для статических активов
      2. Устанавливайте большие значения max-age, чтобы воспользоваться преимуществами кэша браузера
      3. Используйте fingerprint или versioning для борьбы с кэшем.
    НЕ:
      1. Использовать метатеги HTML для определения поведения кэша
      2. Использовать query string для борьбы с кэшем

Best Practice:
  ???

Стратегии кэширования:
  1. Cache only
    Означает, что все запросы отправляются в кэш.
    Когда использовать - Следует использовать, когда вы хотите получить доступ только к статическим активам.

  2. Network only
    Клиент делает запрос, ServiceWorker перехватывает его и передает запрос в сеть.
    Когда использовать - в случаях, не имеющих аналогов в офлайне, таких как аналитические пинги, не-GET запросы.

  3. Cache falling back to network
    ServiceWorker - делает запрос к кэшу, если запрос не успешен, он отправляется в сеть.
    Когда использовать - если вы создаете первое автономное приложение

  4. Network falling back to cache
    Сначала ServiceWorker делает запрос к сети, если запрос успешен - замечательно, иначе происходит откат к кэшу.
    Когда использовать - если вы создаете что-то, что часто меняется, например, страницу публикации или таблицу лидеров
      в игре. Если приоритетом для вас являются самые свежие данные, то эта стратегия является оптимальной.

  5. Generic fallback
    Если оба запроса, один к кэшу, а другой к сети, не выполняются, выводим общий резервный вариант, чтобы у пользователей
      не возникало пустого экрана или какой-либо странной ошибки.

Необходимость внедрения кэширования:
  Традиционно необходимость в кэшировании обусловлена тем, что ваш ответ является результатом запроса, в котором за
    кулисами выполняется множество объединений. Эти соединения требуют больших затрат, задействуют ресурсы, которые не
    могут быть использованы для других запросов, требуют времени для доставки ответа клиенту и эффективно ограничивают
    количество одновременных запросов.

  С развитием таких NoSQL-решений, как CosmosDB и DynamoDB, появилась возможность получать ответы с низкой задержкой
    в масштабе, что может свести на нет необходимость усложнять создание и поддержку инфраструктуры кэширования.

  Прежде чем внедрять кэш в разработку приложения, я рекомендую оценить нефункциональные требования и получить
    доступ к паттернам, которые вы будете использовать. В результате анализа может выясниться, что кэш вообще не нужен.
  Например, если ваше приложение не отправляет информацию обратно человеку, просматривающему ваш сайт электронной коммерции, то,
    возможно, не имеет значения, сколько времени потребуется на обработку запроса - 10 или 100 миллисекунд.

Cache warming:
  Инициализация кэша представляет собой серьезную проблему: следует ли в начальном состоянии
    смириться с тем, что он пуст, или же попытаться заполнить его потенциально запрашиваемыми данными?

  Однозначного ответа на предыдущий вопрос нет. Если держать кэш пустым, то это приведет к многочисленным промахам
    (обращение к кэшу, в котором нет нужных данных).
  Однако попытка угадать запрос на данные и заполнить кэш априори имеет свои издержки.
  Эти затраты компенсируются только в случае правильных выводов.

  Решение о том, как инициализировать (или не инициализировать) кэш-память, в свою очередь, и определяет их категории:
    'Cold Cache' - это пустой кэш или заполненный устаревшими данными. Это означает, что кэш-память не будет ускорять
      обращение к памяти до тех пор, пока она не будет постепенно и естественно заполняться часто востребованными данными
    'Warm Cache' - содержит ценные данные с учетом текущего состояния вычислительной системы. Это означает,
      что мы ожидаем от него большого количества обращений к кэшу (нахождения нужных данных в кэш-памяти).

  'Cache Warming' - процесс предварительной загрузки кэша данными, которые скорее всего будут запрошены пользователями.
  Процесс Cache Warming позволяет заполнить холодный кэш данными с высокой вероятностью запроса.

Всякая всячина:
  1.
    Браузеры кэшируют все различные изображения, HTML, скрипты, таблицы стилей и другое содержимое, чтобы ускорить последующую загрузку страниц.
    Браузер загружает резервный файл HTML и кэширует его. Но браузер использует этот файл только в том случае, если компьютер
      не подключен к интернету, а при наличии подключения браузер запрашивает первый файл

  2. Метатег HTML
    До появления HTML5 использование метатегов внутри HTML для указания cache-control было допустимым:
    <meta http-equiv="Cache-control" content="no-cache">.
    В настоящее время использование такого мета-тега не рекомендуется и не является допустимым в HTML5.
    Всегда передавайте инструкции по кэшированию через HTTP-заголовки.

  3. FAQ:
    1. Как определить что данные загружены с кэша?
      В Chrome эта информация отображается на вкладке Network в колонке Размер.

    2. How do I prevent caching for a file?
      Cache-Control: no-cache, no-store, must-revalidate

  4. HTTP 304 Status Code
    Understanding HTTP 304 Requests:
      Когда браузер сохраняет ресурс в кэше, он сохраняет так называемую информацию о заголовке Last-Modified, который
        был отправлен с сервера. Если браузер получает запрос на веб-страницу, копию которой он сохранил, но не знает,
        последняя ли это версия, он посылает серверу запрос "условной проверки".

      Браузер передает серверу дату и время 'Last-Modified' для имеющейся у него копии ресурса с помощью заголовка
        'If-Modified-Since' или 'If-None-Match'.
      Сервер проверяет эти заголовки, а также смотрит на значение ETag.

      Если значения для этих файлов совпадают, сервер посылает заголовок ответа HTTP 304 Not Modified, и браузер
        использует кэшированную копию ресурса.
      Если же копия браузера устарела, то есть файл был изменен с момента последнего запроса, то посылается код
        HTTP 200 и используется новая копия.

      К сожалению, существует ряд проблем, которые могут привести к появлению ответа HTTP 304, когда он не должен появляться.
      Наиболее распространенные причины включают:
        1. Проблемы с конфигурацией сервера или сервера доменных имен (DNS)
        2. Зараженный или поврежденный кэшированный ресурс (т.е. вредоносное ПО или вирусы, поразившие браузер).
        3. Код состояния 304 может быть вызван проблемой как на стороне сервера, так и на стороне клиента, поэтому для
          его диагностики и устранения может потребоваться определенный поиск неисправностей.

  5. Types of Caches in the Browser (Chrome)
    1. Memory cache:
    2. Disk cache:
    3. ServiceWorker cache:
    4. Push cache:

  6. CDN

  7. Browser Caching vs Proxy Server Caching
    Кэширование через прокси-сервер отличается от браузерного тем, что ресурсы сайта хранятся на промежуточных серверах,
      а не на локальных дисках посетителей.
    В результате одна копия кэшированного ресурса передается нескольким посетителям.

    Если кэш браузера практически полностью контролируется пользователем и может быть удален или изменен по его желанию,
      то кэширование прокси-сервера происходит на стороне CDN.

    Лучше всего регулировать как кэширование в браузере, так и кэширование через прокси-сервер.
    Прокси-кэш может помочь в более сложных сценариях, таких как работа с динамическими или часто обновляемыми ресурсами,
      когда срок действия ресурса истек или когда кэш браузера был очищен.
    Хотя предприятия могут управлять собственными прокси-серверами, большинству проще переложить кэширование и другие задачи по
      доставке контента на CDN.


А?:
фронтенд-инженеры чаще всего сосредоточены на улучшении показателя Lighthouse, который в основном фокусируется на впечатлениях от первой загрузки сайта.