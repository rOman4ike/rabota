# Специфичность 1
При правильном использовании любые селекторы, написанные в формате BEM, должны иметь одинаковую оценку специфичности (0,1,0)

На самом деле есть исключения, когда добавление конкретики считается вполне допустимым. Например, псевдоклассы :hover и :focus.
Они имеют оценку специфичности 0,2,0. Еще один случай - псевдоэлементы ::before и ::after, которые имеют оценку специфичности 0,1,1.

------------------------------------------------------------------------------------------------------------------------

# Специфичность 2
На самом деле есть исключения, когда добавление конкретики считается вполне допустимым. Например, псевдоклассы :hover и :focus.
Они имеют оценку специфичности 0,2,0. Еще один случай - псевдоэлементы ::before и ::after, которые имеют оценку специфичности 0,1,1.

> <span style="color: red;">Важно!</span>
> На практике, если вы обнаружили вложенность более чем на два уровня вглубь, остановитесь и переосмыслите, как вы структурируете свой блок. Скорее всего, вы создаете слишком специфические селекторы и должны соответствующим образом рефакторить свой код.

То, что до сих пор мы избегали повышения конкретики, не означает, что мы никогда этого не сделаем.
Это не плохо по своей сути, и есть время и место для ее использования. Сведя конкретику к минимуму, гораздо проще создать модификатор, который будет переопределять нужные свойства.

Допустим, мы создали кнопку со сплошным фоном, а также модифицированную кнопку с прозрачным фоном и сплошной границей, как здесь:

```scss
.btn {
  display: inline-block;
  margin: 0 auto;
  background: #15DEA5;
  padding: 1rem;

  &--outline {
    background: transparent;
    border: 2px solid #15DEA5;
  }
}
```

Чтобы изобразить отключенную кнопку, нужно сделать ее серой, а значит, создать еще один модификатор.
Можно создать два новых модификатора, по одному для каждой кнопки, но это означает, что придется запоминать больше имен селекторов, не говоря уже о том, что это загромоздит ваш код.

Знаете, что сделает это намного проще? Вы угадали: повышение конкретики!
Мы напишем два новых модификатора, по одному для каждого экземпляра кнопки, но будем использовать одно и то же имя для обоих.
Чтобы различать их, мы воспользуемся вложенностью в Sass для создания селекторов, специфичных для каждого типа кнопок.

```scss
.btn {
  display: inline-block;
  margin: 0 auto;
  background: #15DEA5;
  padding: 1rem;

  &--disabled {
    background: grey;
  }

  &--outline {
    background: transparent;
    border: 2px solid #15DEA5;

    &.btn--disabled{
      border: 2px solid grey;
    }
  }
}

// Мне больше нравится этот вариант
.btn {
  display: inline-block;
  margin: 0 auto;
  background: #15DEA5;
  padding: 1rem;

  &--outline {
    background: transparent;
    border: 2px solid #15DEA5;
  }

  &--disabled {
    background: grey;

    &.btn--outline {
      border: 2px solid grey;
    }
  }
}
```

# Mixins
Если вам не нужно использовать миксины, просто не делайте этого! Почему?

Потому что, когда вы используете миксины, они должны быть хорошо структурированы и поддерживаться строгим образом.
Использование миксинов без веской причины - лучший способ потеряться при росте проекта.
Они могут вызывать побочные эффекты и их трудно обновлять, если они используются во многих местах. Поэтому используйте их осторожно.

Если вы не знаете, стоит ли использовать миксин и когда, запомните одно правило:
Миксины нужны для того, чтобы не повторяться, сохраняя единый источник истины.

# Using Placeholders Can Often Be a Great Tool
```scss
// The placeholder selector
%darkbg {
	border: 1px  solid  #000000;
	background: #101010;
	box-shadow: 0  1px  5px  0  rgba(#404040, 0.6);
}

.my-dark-block-for-errors {
	@extend %darkbg;
	// Some other properties for errors
}

.my-dark-block-for-success {
	@extend %darkbg;
	// Some other properties for success
}
```

# Вложенность
Чрезмерное использование вложенных правил в Sass может вызвать множество проблем, начиная от сложного кода и заканчивая
чрезмерной специфичностью и слишком большой зависимостью от HTML-структуры страницы.
Все это может вызвать проблемы в дальнейшем и потенциально увеличить необходимость включения !important, чего, как правило, следует избегать.

Вот несколько золотых правил для вложенности:
  1. Никогда не углубляйтесь более чем на 3 уровня.
  2. Убедитесь, что CSS-вывод чист и пригоден для повторного использования.
  3. Используйте вложенность, когда это имеет смысл, а не как вариант по умолчанию.

# DRY
Заключительное замечание, которое я сделаю в этом посте, - сохраняйте все как можно более простым.
Цель Sass - писать более чистый и управляемый CSS. Прежде чем создавать новые миксины, переменные или функции, убедитесь,
что их наличие улучшит разработку, а не усложнит ее. Все функции Sass полезны, когда используются в правильных ситуациях и в меру.

Создание бесконечного списка переменных, не имеющих четкого применения, или сложной функции, которую трудно понять кому-либо,
кроме автора, не является целью и не будет способствовать развитию или созданию DRY CSS.

# Magic Numbers
Старайтесь не задавать произвольные числа, потому что они "просто работают"; другие разработчики могут не понять, почему свойство должно быть задано в таких конкретных числах. Вместо этого по возможности создавайте относительные значения.

Если вам интересно, в CSS Tricks есть четкое объяснение того, почему магические числа - это плохо.
https://css-tricks.com/magic-numbers-in-css/

Don't:
```scss
.bad {
  left: 20px;
}
```

Do:
```scss

.good {
  // 20px because of font height
  left: ($GUTTER - 20px - ($NAV_HEIGHT / 2));
}
```

# Zero Values and Units

Don't:
```scss
.not-so-good {
  animation-delay: 0;
  margin: 0px;
  opacity: .4567;
}
```

Do:
```scss
.better {
  animation-delay: 0s;
  margin: 0;
  opacity: 0.4;
}
```

# Nesting Media Queries
Для того чтобы легко находить медиазапросы, рекомендуется размещать их в корне объявления, а не вставлять внутри каждого селектора.

Don't:
```scss
.bad {

  &__area {
    // Code

    @media (min-width: 568px) {
      // Code
    }
  }

  &__section {
    // Code

    @media (min-width: 568px) {
      // Code
    }
  }
}
```

Do:
```scss
.good {

  &__area {
    // Code
  }

  &__section {
    // Code
  }

  @media (min-width: 568px) {
    &__area {
      // Code
    }

    &__section {
      // Code
    }
  }
}
```

# Влияение модификатора
Но когда мне нужно добавить модификатор, изменяющий дочерний элемент с помощью родительского селектора, эта идея быстро рассыпается:

```scss
.card {
  padding: 2em;

  &__value {
    font-size: 1.5em;
    color: #000;
  }

  &--big {
    padding: 2.5em;
  }

  &--big &__value {
    font-size: 3em;
  }
}
```


!!! ПОСИДЕТЬ ПОДУМАТЬ НАД ЭТОЙ ШТУКОЙ
https://www.sitepoint.com/8-tips-help-get-best-sass/


!!! Избавиться от +, ~, > (А НАДО ЛИ) (Есть, :is, :where, :has)

!!! https://sass-guidelin.es/#extend

!!! https://matthewelsom.com/blog/simple-scss-playbook.html